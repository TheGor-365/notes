---------
GO BASICS
---------









-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

hello world
-----------


package main

import "fmt"

func main() {
  fmt.Print("Hello, World!")
}




---






package main





---






func main() {
}




---






import "fmt"




---






fmt.Print("Hello, World!")




---





package pkg

import "fmt"

func HelloWorld() {
  fmt.Print("Hello, World!")
}








-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------










-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

go syntax
---------




import (
    "encoding/json"
    "errors"
    "fmt"
)

type Message struct {
    Sender string `json:"sender"` // —Å—Ç–∞–≤–∏–º —Ç–µ–≥ —Å –æ–ø–∏—Å–∞–Ω–∏–µ–º JSON –ø–æ–ª—è
    Text   string `json:"text"`
}

var errEmptyMessage = errors.New("empty message")

func DecodeJSON(rawMsg string) (Message, error) {
    // –µ—Å–ª–∏ –Ω–∞–º –ø–µ—Ä–µ–¥–∞–ª–∏ –ø—É—Å—Ç—É—é —Å—Ç—Ä–æ–∫—É, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –æ—à–∏–±–∫—É –æ–± —ç—Ç–æ–º
    if len(rawMsg) == 0 {
        return Message{}, errEmptyMessage
    }

    msg := Message{}

    err := json.Unmarshal([]byte(rawMsg), &msg)
    if err != nil {
        return Message{}, fmt.Errorf("unmarshal: %w", err)
    }

    return msg, nil
}




---






func main() {
    msg, err := DecodeJSON("")
    if errors.Is(err, errEmptyMessage) {
        // { } empty message
        fmt.Println(msg, err)
    }

    msg, err = DecodeJSON("hello")
    if err != nil {
        // { } unmarshal: invalid character 'h' looking for beginning of value
        fmt.Println(msg, err)
    }

    msg, err = DecodeJSON(`{"sender":"hexlet","text":"Go,Go,Go"}`)
    // {hexlet Go,Go,Go} <nil>
    fmt.Println(msg, err)
}




---






import (
    "fmt"
    "sync"
)

func main() {
    mu := sync.Mutex{}
    wg := sync.WaitGroup{}

    sum := 0
    for i := 0; i < 10; i++ {
        wg.Add(1)

        go func() {
            n := externalHTTPNum()

            mu.Lock()
            sum += n
            mu.Unlock()

            wg.Done()
        }()
    }

    wg.Wait()

    fmt.Println(sum) // 55
}










-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------










-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

variables
---------




var num int = 11

var num = 11




---






// –¥–≤–æ–µ—Ç–æ—á–∏–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ –ø—Ä–∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏

num := 22
num = 33




---







num := 22
// –ø–æ–ª—É—á–∏–º –æ—à–∏–±–∫—É: cannot use "string" (type untyped string) as type int in assignment
num = "string"




---






longTrickyName := "Josefina"




---






var (
  a string  // ""
  b bool    // false
  c int     // 0
)




---







package math

import "errors"

// —Å—Ç–∞—Ç–∏—á–Ω–∞—è –æ—à–∏–±–∫–∞
var errCannotSum = errors.New("cannot sum")

func sum(...)




---






// –ù–ï Go way
message := "üëé"
buffer := bytes.Buffer{}

// Go way
msg := "üëç"
buf := bytes.Buffer{}




---





package pkg

import "fmt"

func PrintName() {
  firstName := "John"
  lastName := "Smith"

  fmt.Print(firstName + " " + lastName)
}






-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------










-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

functions
---------




func multiply(x int, y int) int {
    return x * y
}




---






package math

func Multiply(x int, y int) int {
}

func divide(x int, y int) int {
}




---






package math

import "errors"

func divide(x, y int) (int, error) {
    if y == 0 {
        return 0, errors.New("cannot divide on zero")
    }

    return x / y, nil
}




---






func multiply(x, y int) (res int) {
    res = x * y
    return
}




---






import "fmt"

func myPrint(msg string) {
    // –ø–∞–∫–µ—Ç.—Ñ—É–Ω–∫—Ü–∏—è
    fmt.Println(msg)
}




---




package pkg

import "strconv"

func IntToString(x int) string {
  return strconv.Itoa(x)
}









-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------










-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

numbers and operations with them
--------------------------------




x := 10
y := 5

x + y
x - y
x / y
x * y




---






x := 5.05
y := 10

x + y  // invalid operation: x + y (mismatched types float64 and int)




---




x := 5.05
y := 10

x + float64(y)




---




x := int64(5.05)      // –æ—à–∏–±–∫–∞ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏: constant 5.05 truncated to integer

x := int64(5.00)      // OK

// uint –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã–º
x := uint(-5)         // constant -5 overflows uint




---






a, _ := strconv.Atoi("-42")
x := uint(a)          // 18446744073709551574

a, _ := strconv.Atoi("5.05")
x := int(a)           // 0




---





func MinInt(x, y int) int {
  return int(math.Min(float64(x), float64(y)))
}









-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------










-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

logic types
-----------




&& - –∏

== - —Ä–∞–≤–Ω–æ

|| - –∏–ª–∏

!  - –Ω–µ




---




true && false
false || true




---






var b bool = true

bs := false




---




true == false

false == false




---






true == "hello"         // invalid operation: false == "hello" (mismatched types untyped bool and untyped string)




---







flag := true
text := "hello"

flag && bool(text)      // cannot convert text (type string) to type bool

flag && text != ""




---





func IsValid(id int, text string) bool {
  return id > 0 && text != ""
}








-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------










-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

strings
-------




var s string = "hello"

s := "hey"




---






q := `
    SELECT *
    FROM person
    WHERE age > 18
`




---




"–ø—Ä–∏–≤–µ—Ç" == "–ø—Ä–∏–≤–µ—Ç"
"golang" > "go"
"golang" > "lang"
"go" > "foobar"




---




"hello " + "world"




---




username := "Ivan"

greetings := fmt.Sprintf("hello, %s", username)




---




len("go")

len("–≥–æ")




---






import (
  "fmt"
  "strings"
)

func Greetings(name string) string {
  name = strings.Trim(name, " ")
  name = strings.ToLower(name)
  name = strings.Title(name) //nolint

  return fmt.Sprintf("–ü—Ä–∏–≤–µ—Ç, %s!", name)
}








-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------










-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

conditional constructions
-------------------------




if "hi" { // non-bool "hi" (type string) used as if condition
}




---






package main

import (
    "fmt"
    "strings"
)

func statusByName(name string) string {
    if strings.HasPrefix(name, "Mr.") {
        return "married man"
    } else if strings.HasPrefix(name, "Mrs.") {
        return "married woman"
    } else {
        return "single person"
    }
}

func main() {
    n := "Mr. Doe"
    fmt.Println(n + " is a " + statusByName(n))

    n = "Mrs. Berry"
    fmt.Println(n + " is a " + statusByName(n))

    n = "Karl"
    fmt.Println(n + " is a " + statusByName(n))
}





---





import (
  "fmt"
)

func DomainForLocale(domain, locale string) string {
  subdomain := ""
  if locale == "" {
    subdomain = "en"
  } else {
    subdomain = locale
  }

  return fmt.Sprintf("%s.%s", subdomain, domain)
}








-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------










-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

switch
------




x := 10

switch x {
    default:
        fmt.Println("default case")
    case 10:
        fmt.Println("case 10")
}
Output:

case 10




---






x := 10

switch {
    default:
        fmt.Println("default case")
    case x == 10:
        fmt.Println("equal 10 case")
        fallthrough
    case x <= 10:
        fmt.Println("less or equal 10 case")
}
Output:

equal 10 case
less or equal 10 case




---






import "strings"

func ModifySpaces(s, mode string) string {
  var replacement string

  switch mode {
  case "dash":
    replacement = "-"
  case "underscore":
    replacement = "_"
  default:
    replacement = "*"
  }

  return strings.ReplaceAll(s, " ", replacement)
}







-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------










-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

structures
----------




type Person struct {
    Name string
    Age int
}

func main() {
    p := Person{Name: "John", Age: 25}

    p.Name
    p.Age
}




---








func main() {
    p := Person{}

    p.Name
    p.Age
}




---






type Person struct {
    Name string

    wallet wallet
}

type wallet struct {
    id string
    moneyAmount float64
}




---






type User struct {
    ID int64 `json:"id" validate:"required"`
    Email string `json:"email" validate:"required,email"`
    FirstName string `json:"first_name" validate:"required"`
}




---






package main

import (
    "encoding/json"
    "fmt"
)

type User struct {
    ID        int64  `json:"id"`
    Email     string `json:"email"`
    FirstName string `json:"first_name"`
}

func main() {
    u := User{}
    u.ID = 22
    u.Email = "test@test.com"
    u.FirstName = "John"

    bs, _ := json.Marshal(u)

    fmt.Println(string(bs))       // {"id":22,"email":"test@test.com","first_name":"John"}
}




---






package main

import (
    "fmt"
    "github.com/go-playground/validator/v10"
)

type User struct {
    ID        int64  `validate:"required"`
    Email     string `validate:"required,email"`
    FirstName string `validate:"required"`
}

func main() {
    // —Å–æ–∑–¥–∞–ª–∏ –ø—É—Å—Ç—É—é —Å—Ç—Ä—É–∫—Ç—É—Ä—É, —á—Ç–æ–±—ã –ø—Ä–æ–≤–µ—Ä–∏—Ç—å –≤–∞–ª–∏–¥–∞—Ü–∏—é
    u := User{}

    // —Å–æ–∑–¥–∞–µ–º –≤–∞–ª–∏–¥–∞—Ç–æ—Ä
    v := validator.New()

    // –º–µ—Ç–æ–¥ Struct –≤–∞–ª–∏–¥–∏—Ä—É–µ—Ç –ø–µ—Ä–µ–¥–∞–Ω–Ω—É—é —Å—Ç—Ä—É–∫—Ç—É—Ä—É –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –æ—à–∏–±–∫—É `error`, –µ—Å–ª–∏ –∫–∞–∫–æ–µ-—Ç–æ –ø–æ–ª–µ –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ
    fmt.Println(v.Struct(u))
}



Key: 'User.ID' Error:Field validation for 'ID' failed on the 'required' tag
Key: 'User.Email' Error:Field validation for 'Email' failed on the 'required' tag
Key: 'User.FirstName' Error:Field validation for 'FirstName' failed on the 'required' tag




---








import (
  "strings"
)

type UserCreateRequest struct {
  FirstName string
  Age       int
}

var (
  invalidRequest = "invalid request"
)

func Validate(req UserCreateRequest) string {
  if req.FirstName == "" || strings.Contains(req.FirstName, " ") {
    return invalidRequest
  }

  if req.Age <= 0 || req.Age > 150 {
    return invalidRequest
  }

  return ""
}











-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------










-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

constants
---------


const StatusOk int = 200




---






const (
    StatusOk = 200
    StatusNotFound = 404
)




---






package main

type Person struct {
}

func main() {
    const (
        num = 20
        str = "hey"
        isValid = true
    )

    const p = Person{}      // –æ—à–∏–±–∫–∞ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏: const initializer Person{} is not a constant
}




---






const (
    StatusOk = 200

    statusInternalError = 500
)




---






package main

import "fmt"

const defaultStatus = 200

func main() {
    const status = 404

    fmt.Println("default status:", defaultStatus) // default status: 200
    fmt.Println("current status:", status) // current status: 404
}




---






package main

import "fmt"

const (
    zero = iota
    one
    two
    three
)

const (
  a = iota
  b = 42
  c = iota
  d
)

func main() {
  fmt.Println(zero, one, two, three)          // 0 1 2 3
  fmt.Println(a, b, c, d)                     // 0, 42, 2, 3
}




---







const (
  OkMsg        = "OK"
  CancelledMsg = "CANCELLED"
)

const (
  OkCode = iota
  CancelledCode
  UnknownCode
)

func ErrorMessageToCode(msg string) int {
  switch msg {
  case OkMsg:
    return OkCode
  case CancelledMsg:
    return CancelledCode
  }

  return UnknownCode
}












-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------










-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

arrays
------


nums := [5]int{}




---




nums := [5]int{}

var nums [5]int




---






nums := [1]int{1,2}       // array index 1 out of bounds [0:1]




---






nums := [3]int{1, 2, 3}

fmt.Println(nums[1])

nums[2] = 33

fmt.Println(nums)




---




words := [2]string{}

words[2]

// invalid array index 2 (out of bounds for 2-element array)




---







package main

import (
    "fmt"
)

func main() {
    a := [3]int{1,2,3}

    modifyArr(a)

    fmt.Println(a)
}

func modifyArr(nums [3]int) {
    nums[0] = 35
}




---





fmt.Println(len([5]int{1,2,3}))
fmt.Println(len([10]int{}))




---




func SafeWrite(nums [5]int, i, val int) [5]int {
  if i >= 0 && i < len(nums) {
    nums[i] = val
  }

  return nums
}







-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------










-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

slices
------


var nums = []int{1,2,3}

nums := []int{1,2,3}




---




nums := []int{1,2,3}

nums[2]

nums[0] = 10

nums[1:3]
nums[:2]
nums[2:]




---




words := []string{"hello"}

words = append(words, "world")




---




nums := make([]int, 5, 5)

nums := make([]int, 0, 5)




---






package main

import (
    "fmt"
)

func main() {
    nums := []int{1, 2, 3, 4, 5}

    modifySlice(nums)

    fmt.Println(nums)
}

func modifySlice(nums []int) {
    nums[2] = 10
    nums = append(nums, 6)
}




---






func Remove(nums []int, i int) []int {
  if i < 0 || i > len(nums)-1 {
    return nums
  }

  nums[i] = nums[len(nums)-1]

  return nums[:len(nums)-1]
}








-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------










-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

for loop
--------


nums := make([]int, 0, 10)

for i := 0; i < 10; i++ {
    nums = append(nums, i)
}

fmt.Println(nums)




---




i := 0
nums := make([]int, 0, 10)

for i < 10 {
    nums = append(nums, i)
    i++
}

fmt.Println(nums)




---




i := 0

nums := make([]int, 0, 10)

for {
    if i == 10 {
        break
    }

    nums = append(nums, i)
    i++
}

fmt.Println(nums)




---




nums := make([]int, 0, 10)

for i := 0; i < 10; i++ {
    if i % 2 != 0 {
        continue
    }

    nums = append(nums, i)
}

fmt.Println(nums)




---






names := []string{"John", "Harold", "Vince"}

for i, name := range names {
    fmt.Println("Hello ", name, " at index ", i)
}



Hello  John  at index  0
Hello  Harold  at index  1
Hello  Vince  at index  2




---




i := 0

nums := make([]int, 0, 10)

for {
    i++
    if i < 2 {
        continue
    }
    if i == 9 {
        break
    }
    nums = append(nums, i)

}

fmt.Println(nums)




---





func Map(strs []string, mapFunc func(s string) string) []string {
  mapped := make([]string, len(strs))
  for i, s := range strs {
    mapped[i] = mapFunc(s)
  }

  return mapped
}







-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------










-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

slices copying
--------------


nums := []int{1,2,3,4,5}

numsCp := make([]int, len(nums))

copy(numsCp, nums)

fmt.Println(numsCp)




---




nums := []int{1,2,3,4,5}

numsCp := nums

numsCp[0] = 10

fmt.Println(nums)




---




nums := []int{1, 2, 3, 4, 5}

numsCp := make([]int, 0)

copy(numsCp, nums)

fmt.Println(numsCp)




---





import "sort"

func IntsCopy(src []int, maxLen int) []int {
  if maxLen <= 0 {
    return []int{}
  }

  if maxLen > len(src) {
    maxLen = len(src)
  }

  cp := make([]int, maxLen)
  copy(cp, src)

  return cp
}







-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------










-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

slices sorting
--------------


nums := []int{2,1,6,5,3,4}

sort.Slice(nums, func(i, j int) bool {
    return nums[i] < nums[j]
})

fmt.Println(nums)




---






func Print(arg interface{}) {
    fmt.Println(arg)
}

func main() {
    Print("hello!")
    Print(123)
    Print([]int{1,5,10})
}



hello!
123
[1 5 10]




---





nums := []int{2,1,6,5,3,4}

sort.SliceStable(nums, func(i, j int) bool {
    return nums[i] < nums[j]
})

fmt.Println(nums)




---





import "sort"

func UniqueSortedUserIDs(userIDs []int64) []int64 {
  if len(userIDs) < 2 {
    return userIDs
  }

  sort.SliceStable(userIDs, func(i, j int) bool { return userIDs[i] < userIDs[j] })
  uniqPointer := 0
  for i := 1; i < len(userIDs); i++ {
    if userIDs[uniqPointer] != userIDs[i] {
      uniqPointer++
      userIDs[uniqPointer] = userIDs[i]
    }
  }

  return userIDs[:uniqPointer+1]
}







-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------










-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

map
---


var m map[int]string

m := map[int]string{}

m := make(map[int]string, 10)

m := map[int]string{1: "hello", 2: "world"}

m[3] = "!"

word := m[1]




---




elements := map[int64]bool{1: true, 2: false}

element, elementExists := elements[1]
element, elementExists := elements[2]
element, elementExists := elements[225]




---




cache := make(map[string]struct{})

_, ok := cache["key"]
fmt.Println(ok)

cache["key"] = struct{}{}
_, ok := cache["key"]
fmt.Println(ok)




---




engToRus := map[string]string{"hello":"–ø—Ä–∏–≤–µ—Ç", "world":"–º–∏—Ä"}

delete(engToRus, "world")

fmt.Println(engToRus)




---






package main

import (
    "fmt"
)

func main() {
    m := map[int]string{1: "hello", 2: "world"}

    modifyMap(m)

    fmt.Println(m) // –≤—ã–≤–æ–¥: map[1:changed 2:world 200:added]
}

func modifyMap(m map[int]string) {
    m[200] = "added"

    m[1] = "changed"
}




---







func UniqueUserIDs(userIDs []int64) []int64 {
  processed := make(map[int64]struct{})

  uniqUserIDs := make([]int64, 0)
  for _, uid := range userIDs {
    _, ok := processed[uid]
    if ok {
      continue
    }

    uniqUserIDs = append(uniqUserIDs, uid)
    processed[uid] = struct{}{}
  }

  return uniqUserIDs
}








-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------










-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

map bypass
----------


idToName := map[int64]string{1: "Alex", 2: "Dan", 3: "George"}

for id, name := range idToName {
    fmt.Println("id: ", id, "name: ", name)
}



id:  1 name:  Alex
id:  2 name:  Dan
id:  3 name:  George




---








numExistence := make(map[int]bool, 0)

for i := 0; i < 10; i++ {
    numExistence[i] = true
}

for num := range numExistence {
    fmt.Println(num)
}




---





func MostPopularWord(words []string) string {
  wordsCount := make(map[string]int, 0)
  mostPopWord := ""
  max := 0

  for i := len(words) - 1; i >= 0; i -= 1 {
    word := words[i]
    wordsCount[word] += 1
    if wordsCount[word] >= max {
      max = wordsCount[word]
      mostPopWord = word
    }
  }

  return mostPopWord
}








-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------










-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

strings and bytes
-----------------


type _string struct {
    elements *byte // –±–∞–π—Ç—ã
    len      int   // –∫–æ–ª-–≤–æ –±–∞–π—Ç
}




---




s := "hello"
s[4] = ""




---






package main

import "fmt"

func main() {
    s := "hey"

    fmt.Println(s[0], s[1], s[2]) // 104 101 121

    fmt.Println(string(s[0]), string(s[1]), string(s[2])) // h e y
}




---






package main

import "fmt"

func main() {
    s := "hey"
    bs := []byte(s)

    fmt.Println([]byte(s))

    fmt.Println(string(bs))
}




---






package main

import (
    "fmt"
    "reflect"
)

func main() {
    asciiCh := byte('Z')
    asciiChStr := string(asciiCh)

    fmt.Println(reflect.TypeOf(asciiCh), asciiCh) // uint8 90

    fmt.Println(reflect.TypeOf(asciiChStr), asciiChStr) // string Z
}





---







func NextASCII(b byte) byte {
  return b + 1
}

func PrevASCII(b byte) byte {
  return b - 1
}









-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------










-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

string bypass
-------------




package main

import (
    "fmt"
)

func main() {
    s := "hello"
    for i := 0; i < len(s); i++ {
        fmt.Println(string(s[i]))
    }

}





---






package main

import (
    "fmt"
)

func main() {
    s := "–ø—Ä–∏–≤–µ—Ç"
    for i := 0; i < len(s); i++ {
        fmt.Println(string(s[i]))
    }

}





---





func GenerateSelfStory(name string, age int, money float64) string {
  return fmt.Sprintf("Hello! My name is %s. I'm %d y.o. And I also have $%.2f in my wallet right now.", name, age, money)
}








-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------










-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

runes
-----


package main

import (
    "fmt"
)

func main() {
    emoji := []rune("–ø—Ä–∏–≤–µ—ÇüòÄ")

    for i := 0; i < len(emoji); i++ {
        fmt.Println(emoji[i], string(emoji[i]))
    }
}




1087 –ø
1088 —Ä
1080 –∏
1074 –≤
1077 –µ
1090 —Ç
128512 üòÄ




---




s := "heyüòâ"

rs := []rune([]byte(s))

bs := []byte([]rune(s))




---






package main

import (
    "fmt"
)

func main() {
    emoji := []rune("coolüòÄ")

    for _, ch := range emoji {
        fmt.Println(ch, string(ch))
    }
}



99 c
111 o
111 o
108 l
128512 üòÄ




---







func IsASCII(s string) bool {
  for _, r := range s {
    if r > unicode.MaxASCII {
      return false
    }
  }

  return true
}










-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------










-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

standart package string
-----------------------


import "strings"

strings.Contains("hello", "h") // true

strings.Split("hello", "") // ["h", "e", "l", "l", "o"]

strings.Join([]string{"hello","world!"}, " ")




---




import "strings"

sb := strings.Builder{}

sb.WriteString("hello")
sb.WriteString(" ")
sb.WriteString("world")

sb.String()




---






func LatinLetters(s string) string {
  sb := &strings.Builder{}

  for _, r := range s {
    if unicode.Is(unicode.Latin, r) {
      sb.WriteRune(r)
    }
  }

  return sb.String()
}







-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------










-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

string formating
----------------


s := "hello world"

fmt.Println(s)




---




name := "Andy"

fmt.Sprintf("hello %s", name) // "hello Andy"

fmt.Sprintf("there are %d kittens", 10) // "there are 10 kittens"

fmt.Sprintf("your story is %t", true)




---






package main

import (
    "fmt"
)

type Person struct {
    Name string
    Age  int
}

func main() {
    p := Person{Name: "Andy", Age: 18}

    fmt.Println("simple struct:", p)

    fmt.Printf("detailed struct: %+v\n", p)

    fmt.Printf("Golang struct: %#v\n", p)
}



simple struct: {Andy 18}
detailed struct: {Name:Andy Age:18}
Golang struct: main.Person{Name:"Andy", Age:18}




---






func GenerateSelfStory(name string, age int, money float64) string {
  return fmt.Sprintf("Hello! My name is %s. I'm %d y.o. And I also have $%.2f in my wallet right now.", name, age, money)
}









-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------










-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

variative functions
-------------------


package main

import (
    "fmt"
)

func main() {
    // –∫–æ–ª-–≤–æ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤ –º–æ–∂–µ—Ç –±—ã—Ç—å –ª—é–±—ã–º
    PrintNums(1, 2, 3)
}


func PrintNums(nums ...int) {
    for _, n := range nums {
        fmt.Println(n)
    }
}




---




nums1 := []int{1,2,3,4,5}

nums2 := []int{6,7,8,9,10}

res := append(nums1, nums2...)




---






func MergeNumberLists(numberLists ...[]int) []int {
  mergedCap := 0
  for i := 0; i < len(numberLists); i++ {
    mergedCap += len(numberLists[i])
  }

  merged := make([]int, 0, mergedCap)
  for _, nl := range numberLists {
    merged = append(merged, nl...)
  }

  return merged
}









-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------










-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

pointers
--------


package main

import (
    "fmt"
)

type User struct {
    email    string
    password string
}

func fillUserData(u *User, email string, pass string) {
    u.email = email
    u.password = pass
}

func main() {
    u := User{}

    fillUserData(&u, "test@test.com", "qwerty")

    fmt.Printf("points on func call %+v\n", u)

    up := &User{}

    fillUserData(up, "test@test.com", "qwerty")

    fmt.Printf("points on init %+v\n", up)
}




---






package main

import (
    "fmt"
)

func main() {
    m := map[string]int{}

    fillMap(m)

    fmt.Println(m) // map[random:1]
}

func fillMap(m map[string]int) {
    m["random"] = 1
}




---







type Parent struct {
  Name     string
  Children []Child
}

type Child struct {
  Name string
  Age  int
}

func CopyParent(p *Parent) Parent {
  if p == nil {
    return Parent{}
  }
  children := make([]Child, len(p.Children))
  copy(children, p.Children)
  return Parent{
    Name:     p.Name,
    Children: children,
  }
}








-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------










-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

structure methods
-----------------


package main

import (
    "fmt"
)

type Dog struct{}

func (d Dog) Bark() {
    fmt.Println("woof!")
}

func main() {
    d := Dog{}
    d.Bark() // woof!
}




---






package main

import (
    "fmt"
)

type Dog struct {
    IsBarked bool
}

func (d Dog) Bark() {
    fmt.Println("woof!")
    d.IsBarked = true
}

func main() {
    d := Dog{}
    d.Bark() // woof!

    fmt.Println(d.IsBarked) // false
}




---






package main

import (
    "fmt"
)

type Dog struct {
    IsBarked bool
}

func (d *Dog) Bark() {
    fmt.Println("woof!")
    d.IsBarked = true
}

func main() {
    d := &Dog{}
    d.Bark() // woof!

    fmt.Println(d.IsBarked) // true
}




---





type Counter struct {
  Value int
}

func Max(x, y int) int {
  if x < y {
    return y
  }
  return x
}

func (c *Counter) Inc(delta int) {
  if delta == 0 {
    delta = 1
  }
  c.Value = Max(c.Value+delta, 0)
}

func (c *Counter) Dec(delta int) {
  if delta == 0 {
    delta = 1
  }
  c.Inc(-delta)
}









-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------










-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

custom types
------------


type NumCount int

func main() {
    nc := NumCount(len([]int{1, 2, 3}))

    fmt.Println(nc)
}




---






type errorCode string

func main() {
    ec := errorCode("internal")

    fmt.Println(ec)

    fmt.Println(string(ec))
}




---






type counter int


func (c *counter) inc() {
    *c++
}

func main() {
    c := counter(0)
    (&c).inc()
    (&c).inc()

    fmt.Println(c)
}




---




















-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------










-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

errors
------


import "errors"

func validateName(name string) error {
    if name == "" {
        // errors.New —Å–æ–∑–¥–∞–µ—Ç –Ω–æ–≤—ã–π –æ–±—ä–µ–∫—Ç –æ—à–∏–±–∫–∏
        return errors.New("empty name")
    }

    if len([]rune(name)) > 50 {
        return errors.New("a name cannot be more than 50 characters")
    }

    return nil
}




---






package main

import (
    "fmt"
)

type Printer interface {
    Print()
}

type User struct {
    email string
}

func (u *User) Print() {
    fmt.Println("My email is", u.email)
}

func TestPrint(p Printer) {
    p.Print()
}

func main() {
    TestPrint(&User{email: "test@test.com"})
}




---




type error interface {
    Error() string
}




---






type TimeoutErr struct {
    msg string
}

func (e *TimeoutErr) Error() string {
    return e.msg
}




---




func DoHTTPCall(r Request) (Response, error) {
}




---


















-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------










-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

error handling
--------------


import "log"

response, err := DoHTTPCall()
if err != nil {
    log.Println(err)
}




---






package main

import (
    "errors"
    "fmt"
)

func DoHTTPCall() error {
    err := SendTCP()
    if err != nil {
        return fmt.Errorf("send tcp: %w", err)
    }

    return nil
}

var errTCPConnectionIssue = errors.New("TCP connect issue")

func SendTCP() error {
    return errTCPConnectionIssue
}

func main() {
    fmt.Println(DoHTTPCall())
}




---






err := DoHTTPCall()
if err != nil {
    if errors.Is(err, errTCPConnectionIssue) {
        time.Sleep(1 * time.Second)
        return DoHTTPCall()
    }

    log.Println("unknown error on HTTP call", err)
}




---






package main

import (
    "errors"
    "log"
    "time"
)

type ConnectionErr struct{}

func (e ConnectionErr) Error() string {
    return "connection err"
}

func main() {
    tries := 0
    for {
        if tries > 2 {
            log.Println("Can't connect to DB")
            break
        }

        err := connectDB()
        if err != nil {
            if errors.As(err, &ConnectionErr{}) {
                log.Println("Connection error. Trying to reconnect...")
                time.Sleep(1 * time.Second)
                tries++
                continue
            }

            log.Println("connect DB critical error", err)
        }

        break
    }
}

func connectDB() error {
    return ConnectionErr{}
}




Connection error. Trying to reconnect...
Connection error. Trying to reconnect...
Connection error. Trying to reconnect...
Can't connect to DB






---


















-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------










-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

deferred functions
------------------


package main

import (
    "fmt"
)

func main() {
    defer fmt.Println("finish")

    fmt.Println("start")
}



start
finish




---








package main

import (
    "fmt"
)

func main() {
    defer fmt.Println("3rd")
    defer fmt.Println("2nd")

    fmt.Println("1st")
}




1st
2nd
3rd




---












-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------










-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

introduction to multithreading
------------------------------


package main

import (
    "fmt"
    "time"
)

func main() {
    go fmt.Println("Hello concurrent world")

    time.Sleep(100 * time.Millisecond)
}




---






package main

import (
    "fmt"
    "time"
)

func main() {
    for i := 0; i < 5; i++ {
        go func() {
            fmt.Println(i)
        }()
    }

    time.Sleep(100 * time.Millisecond)
}



5
5
5
5
5




---






package main

import (
    "fmt"
    "time"
)

func main() {
    for i := 0; i < 5; i++ {
        go func(i int) {
            fmt.Println(i)
        }(i)
    }

    time.Sleep(100 * time.Millisecond)
}




0
4
3
1
2




---














-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------










-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

channels
--------


numCh := make(chan int)




---




numCh := make(chan int)

numCh <- 10

num := <- numCh




---






package main

import (
    "fmt"
)

func main() {
    numCh := make(chan int)

    <-numCh

    fmt.Println("program has ended") // —ç—Ç–∞ —Å—Ç—Ä–æ–∫–∞ –Ω–∏–∫–æ–≥–¥–∞ –Ω–µ –≤—ã–≤–µ–¥–µ—Ç—Å—è
}




---






package main

import (
    "fmt"
)

func main() {
    fmt.Println(maxSum([]int{1, 2, 3}, []int{10, 20, 50})) // [10 20 50]
}

func maxSum(nums1, nums2 []int) []int {
    s1Ch := make(chan int)
    go sumParallel(nums1, s1Ch)

    s2Ch := make(chan int)
    go sumParallel(nums2, s2Ch)

    s1, s2 := <-s1Ch, <-s2Ch

    if s1 > s2 {
        return nums1
    }

    return nums2
}

func sumParallel(nums []int, resCh chan int) {
    s := 0
    for _, n := range nums {
        s += n
    }

    resCh <- s
}




---






package main

import (
    "fmt"
    "time"
)

func main() {
    msgCh := make(chan string)

    go printer(msgCh)

    msgCh <- "hello"
    msgCh <- "concurrent"
    msgCh <- "world"

    close(msgCh)

    time.Sleep(100 * time.Millisecond)
}

func printer(msgCh chan string) {
    for msg := range msgCh {
        fmt.Println(msg)
    }

    fmt.Println("printer has finished")
}




---




















-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------










-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------





















































































